/* automatically generated by rust-bindgen 0.70.1 */

pub const FLECS_VERSION_MAJOR: u32 = 4;
pub const FLECS_VERSION_MINOR: u32 = 0;
pub const FLECS_VERSION_PATCH: u32 = 1;
pub const FLECS_HI_COMPONENT_ID: u32 = 256;
pub const FLECS_HI_ID_RECORD_ID: u32 = 1024;
pub const FLECS_SPARSE_PAGE_BITS: u32 = 12;
pub const FLECS_ENTITY_PAGE_BITS: u32 = 12;
pub const FLECS_ID_DESC_MAX: u32 = 32;
pub const FLECS_EVENT_DESC_MAX: u32 = 8;
pub const FLECS_VARIABLE_COUNT_MAX: u32 = 64;
pub const FLECS_TERM_COUNT_MAX: u32 = 32;
pub const FLECS_TERM_ARG_COUNT_MAX: u32 = 16;
pub const FLECS_QUERY_VARIABLE_COUNT_MAX: u32 = 64;
pub const FLECS_QUERY_SCOPE_NESTING_MAX: u32 = 8;
pub const EcsWorldQuitWorkers: u32 = 1;
pub const EcsWorldReadonly: u32 = 2;
pub const EcsWorldInit: u32 = 4;
pub const EcsWorldQuit: u32 = 8;
pub const EcsWorldFini: u32 = 16;
pub const EcsWorldMeasureFrameTime: u32 = 32;
pub const EcsWorldMeasureSystemTime: u32 = 64;
pub const EcsWorldMultiThreaded: u32 = 128;
pub const EcsOsApiHighResolutionTimer: u32 = 1;
pub const EcsOsApiLogWithColors: u32 = 2;
pub const EcsOsApiLogWithTimeStamp: u32 = 4;
pub const EcsOsApiLogWithTimeDelta: u32 = 8;
pub const EcsEntityIsId: u32 = 2147483648;
pub const EcsEntityIsTarget: u32 = 1073741824;
pub const EcsEntityIsTraversable: u32 = 536870912;
pub const EcsIdOnDeleteRemove: u32 = 1;
pub const EcsIdOnDeleteDelete: u32 = 2;
pub const EcsIdOnDeletePanic: u32 = 4;
pub const EcsIdOnDeleteMask: u32 = 7;
pub const EcsIdOnDeleteObjectRemove: u32 = 8;
pub const EcsIdOnDeleteObjectDelete: u32 = 16;
pub const EcsIdOnDeleteObjectPanic: u32 = 32;
pub const EcsIdOnDeleteObjectMask: u32 = 56;
pub const EcsIdOnInstantiateOverride: u32 = 64;
pub const EcsIdOnInstantiateInherit: u32 = 128;
pub const EcsIdOnInstantiateDontInherit: u32 = 256;
pub const EcsIdOnInstantiateMask: u32 = 448;
pub const EcsIdExclusive: u32 = 512;
pub const EcsIdTraversable: u32 = 1024;
pub const EcsIdTag: u32 = 2048;
pub const EcsIdWith: u32 = 4096;
pub const EcsIdCanToggle: u32 = 8192;
pub const EcsIdIsTransitive: u32 = 16384;
pub const EcsIdHasOnAdd: u32 = 65536;
pub const EcsIdHasOnRemove: u32 = 131072;
pub const EcsIdHasOnSet: u32 = 262144;
pub const EcsIdHasOnTableFill: u32 = 1048576;
pub const EcsIdHasOnTableEmpty: u32 = 2097152;
pub const EcsIdHasOnTableCreate: u32 = 4194304;
pub const EcsIdHasOnTableDelete: u32 = 8388608;
pub const EcsIdIsSparse: u32 = 16777216;
pub const EcsIdIsUnion: u32 = 33554432;
pub const EcsIdEventMask: u32 = 66519040;
pub const EcsIdMarkedForDelete: u32 = 1073741824;
pub const EcsIterIsValid: u32 = 1;
pub const EcsIterNoData: u32 = 2;
pub const EcsIterNoResults: u32 = 8;
pub const EcsIterIgnoreThis: u32 = 16;
pub const EcsIterHasCondSet: u32 = 64;
pub const EcsIterProfile: u32 = 128;
pub const EcsIterTrivialSearch: u32 = 256;
pub const EcsIterTrivialTest: u32 = 2048;
pub const EcsIterTrivialCached: u32 = 16384;
pub const EcsIterCacheSearch: u32 = 32768;
pub const EcsIterFixedInChangeComputed: u32 = 65536;
pub const EcsIterFixedInChanged: u32 = 131072;
pub const EcsIterSkip: u32 = 262144;
pub const EcsIterCppEach: u32 = 524288;
pub const EcsIterTableOnly: u32 = 1048576;
pub const EcsEventTableOnly: u32 = 1048576;
pub const EcsEventNoOnSet: u32 = 65536;
pub const EcsQueryMatchThis: u32 = 2048;
pub const EcsQueryMatchOnlyThis: u32 = 4096;
pub const EcsQueryMatchOnlySelf: u32 = 8192;
pub const EcsQueryMatchWildcards: u32 = 16384;
pub const EcsQueryHasCondSet: u32 = 32768;
pub const EcsQueryHasPred: u32 = 65536;
pub const EcsQueryHasScopes: u32 = 131072;
pub const EcsQueryHasRefs: u32 = 262144;
pub const EcsQueryHasOutTerms: u32 = 524288;
pub const EcsQueryHasNonThisOutTerms: u32 = 1048576;
pub const EcsQueryHasMonitor: u32 = 2097152;
pub const EcsQueryIsTrivial: u32 = 4194304;
pub const EcsQueryHasCacheable: u32 = 8388608;
pub const EcsQueryIsCacheable: u32 = 16777216;
pub const EcsQueryHasTableThisVar: u32 = 33554432;
pub const EcsQueryCacheYieldEmptyTables: u32 = 134217728;
pub const EcsTermMatchAny: u32 = 1;
pub const EcsTermMatchAnySrc: u32 = 2;
pub const EcsTermTransitive: u32 = 4;
pub const EcsTermReflexive: u32 = 8;
pub const EcsTermIdInherited: u32 = 16;
pub const EcsTermIsTrivial: u32 = 32;
pub const EcsTermIsCacheable: u32 = 128;
pub const EcsTermIsScope: u32 = 256;
pub const EcsTermIsMember: u32 = 512;
pub const EcsTermIsToggle: u32 = 1024;
pub const EcsTermKeepAlive: u32 = 2048;
pub const EcsTermIsSparse: u32 = 4096;
pub const EcsTermIsUnion: u32 = 8192;
pub const EcsTermIsOr: u32 = 16384;
pub const EcsObserverIsMulti: u32 = 2;
pub const EcsObserverIsMonitor: u32 = 4;
pub const EcsObserverIsDisabled: u32 = 8;
pub const EcsObserverIsParentDisabled: u32 = 16;
pub const EcsObserverBypassQuery: u32 = 32;
pub const EcsTableHasBuiltins: u32 = 2;
pub const EcsTableIsPrefab: u32 = 4;
pub const EcsTableHasIsA: u32 = 8;
pub const EcsTableHasChildOf: u32 = 16;
pub const EcsTableHasName: u32 = 32;
pub const EcsTableHasPairs: u32 = 64;
pub const EcsTableHasModule: u32 = 128;
pub const EcsTableIsDisabled: u32 = 256;
pub const EcsTableNotQueryable: u32 = 512;
pub const EcsTableHasCtors: u32 = 1024;
pub const EcsTableHasDtors: u32 = 2048;
pub const EcsTableHasCopy: u32 = 4096;
pub const EcsTableHasMove: u32 = 8192;
pub const EcsTableHasToggle: u32 = 16384;
pub const EcsTableHasOverrides: u32 = 32768;
pub const EcsTableHasOnAdd: u32 = 65536;
pub const EcsTableHasOnRemove: u32 = 131072;
pub const EcsTableHasOnSet: u32 = 262144;
pub const EcsTableHasOnTableFill: u32 = 1048576;
pub const EcsTableHasOnTableEmpty: u32 = 2097152;
pub const EcsTableHasOnTableCreate: u32 = 4194304;
pub const EcsTableHasOnTableDelete: u32 = 8388608;
pub const EcsTableHasSparse: u32 = 16777216;
pub const EcsTableHasUnion: u32 = 33554432;
pub const EcsTableHasTraversable: u32 = 67108864;
pub const EcsTableMarkedForDelete: u32 = 1073741824;
pub const EcsTableHasLifecycle: u32 = 3072;
pub const EcsTableIsComplex: u32 = 16796672;
pub const EcsTableHasAddActions: u32 = 328712;
pub const EcsTableHasRemoveActions: u32 = 133128;
pub const EcsAperiodicEmptyTables: u32 = 2;
pub const EcsAperiodicComponentMonitors: u32 = 4;
pub const EcsAperiodicEmptyQueries: u32 = 16;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const ecs_world_t_magic: u32 = 1701016439;
pub const ecs_stage_t_magic: u32 = 1701016435;
pub const ecs_query_t_magic: u32 = 1701016437;
pub const ecs_observer_t_magic: u32 = 1701016418;
pub const ECS_ROW_MASK: u32 = 268435455;
pub const ECS_ROW_FLAGS_MASK: i32 = -268435456;
pub const ECS_ID_FLAGS_MASK: i64 = -1152921504606846976;
pub const ECS_ENTITY_MASK: u32 = 4294967295;
pub const ECS_GENERATION_MASK: u64 = 281470681743360;
pub const ECS_COMPONENT_MASK: u64 = 1152921504606846975;
pub const EcsIterNextYield: u32 = 0;
pub const EcsIterYield: i32 = -1;
pub const EcsIterNext: u32 = 1;
pub const FLECS_SPARSE_PAGE_SIZE: u32 = 4096;
pub const ECS_STACK_PAGE_SIZE: u32 = 4096;
pub const ECS_STRBUF_SMALL_STRING_SIZE: u32 = 512;
pub const ECS_STRBUF_MAX_LIST_DEPTH: u32 = 32;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX: &[u8; 1] = b"\0";
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION: u32 = 1;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR: u32 = 2;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS: u32 = 4;
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 8;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS: u32 = 16;
pub const _CRT_INTERNAL_PRINTF_STANDARD_ROUNDING: u32 = 32;
pub const _CRT_INTERNAL_SCANF_SECURECRT: u32 = 1;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS: u32 = 2;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY: u32 = 4;
pub const BUFSIZ: u32 = 512;
pub const _NSTREAM_: u32 = 512;
pub const _IOB_ENTRIES: u32 = 3;
pub const EOF: i32 = -1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 64;
pub const _IONBF: u32 = 4;
pub const L_tmpnam: u32 = 260;
pub const L_tmpnam_s: u32 = 260;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const FILENAME_MAX: u32 = 260;
pub const FOPEN_MAX: u32 = 20;
pub const _SYS_OPEN: u32 = 20;
pub const TMP_MAX: u32 = 2147483647;
pub const TMP_MAX_S: u32 = 2147483647;
pub const _TMP_MAX_S: u32 = 2147483647;
pub const SYS_OPEN: u32 = 20;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const EcsSelf: i64 = -9223372036854775808;
pub const EcsUp: u64 = 4611686018427387904;
pub const EcsTrav: u64 = 2305843009213693952;
pub const EcsCascade: u64 = 1152921504606846976;
pub const EcsDesc: u64 = 576460752303423488;
pub const EcsIsVariable: u64 = 288230376151711744;
pub const EcsIsEntity: u64 = 144115188075855872;
pub const EcsIsName: u64 = 72057594037927936;
pub const EcsTraverseFlags: i64 = -576460752303423488;
pub const EcsTermRefFlags: i64 = -72057594037927936;
pub const flecs_iter_cache_ids: u32 = 1;
pub const flecs_iter_cache_trs: u32 = 2;
pub const flecs_iter_cache_sources: u32 = 4;
pub const flecs_iter_cache_ptrs: u32 = 8;
pub const flecs_iter_cache_variables: u32 = 16;
pub const flecs_iter_cache_all: u32 = 255;
pub const ECS_MAX_RECURSION: u32 = 512;
pub const ECS_MAX_TOKEN_SIZE: u32 = 256;
pub const EcsQueryMatchPrefab: u32 = 2;
pub const EcsQueryMatchDisabled: u32 = 4;
pub const EcsQueryMatchEmptyTables: u32 = 8;
pub const EcsQueryAllowUnresolvedByName: u32 = 64;
pub const EcsQueryTableOnly: u32 = 128;
pub const EcsFirstUserComponentId: u32 = 8;
pub const EcsFirstUserEntityId: u32 = 384;
pub const ECS_INVALID_OPERATION: u32 = 1;
pub const ECS_INVALID_PARAMETER: u32 = 2;
pub const ECS_CONSTRAINT_VIOLATED: u32 = 3;
pub const ECS_OUT_OF_MEMORY: u32 = 4;
pub const ECS_OUT_OF_RANGE: u32 = 5;
pub const ECS_UNSUPPORTED: u32 = 6;
pub const ECS_INTERNAL_ERROR: u32 = 7;
pub const ECS_ALREADY_DEFINED: u32 = 8;
pub const ECS_MISSING_OS_API: u32 = 9;
pub const ECS_OPERATION_FAILED: u32 = 10;
pub const ECS_INVALID_CONVERSION: u32 = 11;
pub const ECS_ID_IN_USE: u32 = 12;
pub const ECS_CYCLE_DETECTED: u32 = 13;
pub const ECS_LEAK_DETECTED: u32 = 14;
pub const ECS_DOUBLE_FREE: u32 = 15;
pub const ECS_INCONSISTENT_NAME: u32 = 20;
pub const ECS_NAME_IN_USE: u32 = 21;
pub const ECS_NOT_A_COMPONENT: u32 = 22;
pub const ECS_INVALID_COMPONENT_SIZE: u32 = 23;
pub const ECS_INVALID_COMPONENT_ALIGNMENT: u32 = 24;
pub const ECS_COMPONENT_NOT_REGISTERED: u32 = 25;
pub const ECS_INCONSISTENT_COMPONENT_ID: u32 = 26;
pub const ECS_INCONSISTENT_COMPONENT_ACTION: u32 = 27;
pub const ECS_MODULE_UNDEFINED: u32 = 28;
pub const ECS_MISSING_SYMBOL: u32 = 29;
pub const ECS_ALREADY_IN_USE: u32 = 30;
pub const ECS_ACCESS_VIOLATION: u32 = 40;
pub const ECS_COLUMN_INDEX_OUT_OF_RANGE: u32 = 41;
pub const ECS_COLUMN_IS_NOT_SHARED: u32 = 42;
pub const ECS_COLUMN_IS_SHARED: u32 = 43;
pub const ECS_COLUMN_TYPE_MISMATCH: u32 = 45;
pub const ECS_INVALID_WHILE_READONLY: u32 = 70;
pub const ECS_LOCKED_STORAGE: u32 = 71;
pub const ECS_INVALID_FROM_WORKER: u32 = 72;
pub const ECS_BLACK: &[u8; 8] = b"\x1B[1;30m\0";
pub const ECS_RED: &[u8; 8] = b"\x1B[0;31m\0";
pub const ECS_GREEN: &[u8; 8] = b"\x1B[0;32m\0";
pub const ECS_YELLOW: &[u8; 8] = b"\x1B[0;33m\0";
pub const ECS_BLUE: &[u8; 8] = b"\x1B[0;34m\0";
pub const ECS_MAGENTA: &[u8; 8] = b"\x1B[0;35m\0";
pub const ECS_CYAN: &[u8; 8] = b"\x1B[0;36m\0";
pub const ECS_WHITE: &[u8; 8] = b"\x1B[1;37m\0";
pub const ECS_GREY: &[u8; 8] = b"\x1B[0;37m\0";
pub const ECS_NORMAL: &[u8; 8] = b"\x1B[0;49m\0";
pub const ECS_BOLD: &[u8; 8] = b"\x1B[1;49m\0";
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __crt_locale_data_public"]
        [::std::mem::size_of::<__crt_locale_data_public>() - 16usize];
    ["Alignment of __crt_locale_data_public"]
        [::std::mem::align_of::<__crt_locale_data_public>() - 8usize];
    ["Offset of field: __crt_locale_data_public::_locale_pctype"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_pctype) - 0usize];
    ["Offset of field: __crt_locale_data_public::_locale_mb_cur_max"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_mb_cur_max) - 8usize];
    ["Offset of field: __crt_locale_data_public::_locale_lc_codepage"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_lc_codepage) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __crt_locale_pointers"][::std::mem::size_of::<__crt_locale_pointers>() - 16usize];
    ["Alignment of __crt_locale_pointers"]
        [::std::mem::align_of::<__crt_locale_pointers>() - 8usize];
    ["Offset of field: __crt_locale_pointers::locinfo"]
        [::std::mem::offset_of!(__crt_locale_pointers, locinfo) - 0usize];
    ["Offset of field: __crt_locale_pointers::mbcinfo"]
        [::std::mem::offset_of!(__crt_locale_pointers, mbcinfo) - 8usize];
};
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Mbstatet"][::std::mem::size_of::<_Mbstatet>() - 8usize];
    ["Alignment of _Mbstatet"][::std::mem::align_of::<_Mbstatet>() - 4usize];
    ["Offset of field: _Mbstatet::_Wchar"][::std::mem::offset_of!(_Mbstatet, _Wchar) - 0usize];
    ["Offset of field: _Mbstatet::_Byte"][::std::mem::offset_of!(_Mbstatet, _Byte) - 4usize];
    ["Offset of field: _Mbstatet::_State"][::std::mem::offset_of!(_Mbstatet, _State) - 6usize];
};
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _wassert(_Message: *const wchar_t, _File: *const wchar_t, _Line: ::std::os::raw::c_uint);
}
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type ecs_flags8_t = u8;
pub type ecs_flags16_t = u16;
pub type ecs_flags32_t = u32;
pub type ecs_flags64_t = u64;
pub type ecs_size_t = i32;
#[doc = " A component column."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_vec_t {
    pub array: *mut ::std::os::raw::c_void,
    pub count: i32,
    pub size: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_vec_t"][::std::mem::size_of::<ecs_vec_t>() - 16usize];
    ["Alignment of ecs_vec_t"][::std::mem::align_of::<ecs_vec_t>() - 8usize];
    ["Offset of field: ecs_vec_t::array"][::std::mem::offset_of!(ecs_vec_t, array) - 0usize];
    ["Offset of field: ecs_vec_t::count"][::std::mem::offset_of!(ecs_vec_t, count) - 8usize];
    ["Offset of field: ecs_vec_t::size"][::std::mem::offset_of!(ecs_vec_t, size) - 12usize];
};
extern "C" {
    pub fn ecs_vec_init(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_init_if(vec: *mut ecs_vec_t, size: ecs_size_t);
}
extern "C" {
    pub fn ecs_vec_fini(allocator: *mut ecs_allocator_t, vec: *mut ecs_vec_t, size: ecs_size_t);
}
extern "C" {
    pub fn ecs_vec_reset(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
    ) -> *mut ecs_vec_t;
}
extern "C" {
    pub fn ecs_vec_clear(vec: *mut ecs_vec_t);
}
extern "C" {
    pub fn ecs_vec_append(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_remove(vec: *mut ecs_vec_t, size: ecs_size_t, elem: i32);
}
extern "C" {
    pub fn ecs_vec_remove_last(vec: *mut ecs_vec_t);
}
extern "C" {
    pub fn ecs_vec_copy(
        allocator: *mut ecs_allocator_t,
        vec: *const ecs_vec_t,
        size: ecs_size_t,
    ) -> ecs_vec_t;
}
extern "C" {
    pub fn ecs_vec_copy_shrink(
        allocator: *mut ecs_allocator_t,
        vec: *const ecs_vec_t,
        size: ecs_size_t,
    ) -> ecs_vec_t;
}
extern "C" {
    pub fn ecs_vec_reclaim(allocator: *mut ecs_allocator_t, vec: *mut ecs_vec_t, size: ecs_size_t);
}
extern "C" {
    pub fn ecs_vec_set_size(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_min_size(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_min_count(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_min_count_zeromem(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_set_count(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    );
}
extern "C" {
    pub fn ecs_vec_grow(
        allocator: *mut ecs_allocator_t,
        vec: *mut ecs_vec_t,
        size: ecs_size_t,
        elem_count: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_count(vec: *const ecs_vec_t) -> i32;
}
extern "C" {
    pub fn ecs_vec_size(vec: *const ecs_vec_t) -> i32;
}
extern "C" {
    pub fn ecs_vec_get(
        vec: *const ecs_vec_t,
        size: ecs_size_t,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_first(vec: *const ecs_vec_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_vec_last(vec: *const ecs_vec_t, size: ecs_size_t) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_sparse_t {
    pub dense: ecs_vec_t,
    pub pages: ecs_vec_t,
    pub size: ecs_size_t,
    pub count: i32,
    pub max_id: u64,
    pub allocator: *mut ecs_allocator_t,
    pub page_allocator: *mut ecs_block_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_sparse_t"][::std::mem::size_of::<ecs_sparse_t>() - 64usize];
    ["Alignment of ecs_sparse_t"][::std::mem::align_of::<ecs_sparse_t>() - 8usize];
    ["Offset of field: ecs_sparse_t::dense"][::std::mem::offset_of!(ecs_sparse_t, dense) - 0usize];
    ["Offset of field: ecs_sparse_t::pages"][::std::mem::offset_of!(ecs_sparse_t, pages) - 16usize];
    ["Offset of field: ecs_sparse_t::size"][::std::mem::offset_of!(ecs_sparse_t, size) - 32usize];
    ["Offset of field: ecs_sparse_t::count"][::std::mem::offset_of!(ecs_sparse_t, count) - 36usize];
    ["Offset of field: ecs_sparse_t::max_id"]
        [::std::mem::offset_of!(ecs_sparse_t, max_id) - 40usize];
    ["Offset of field: ecs_sparse_t::allocator"]
        [::std::mem::offset_of!(ecs_sparse_t, allocator) - 48usize];
    ["Offset of field: ecs_sparse_t::page_allocator"]
        [::std::mem::offset_of!(ecs_sparse_t, page_allocator) - 56usize];
};
extern "C" {
    #[doc = " Initialize sparse set"]
    pub fn flecs_sparse_init(
        result: *mut ecs_sparse_t,
        allocator: *mut ecs_allocator_t,
        page_allocator: *mut ecs_block_allocator_t,
        size: ecs_size_t,
    );
}
extern "C" {
    pub fn flecs_sparse_fini(sparse: *mut ecs_sparse_t);
}
extern "C" {
    #[doc = " Remove all elements from sparse set"]
    pub fn flecs_sparse_clear(sparse: *mut ecs_sparse_t);
}
extern "C" {
    #[doc = " Add element to sparse set, this generates or recycles an id"]
    pub fn flecs_sparse_add(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get last issued id."]
    pub fn flecs_sparse_last_id(sparse: *const ecs_sparse_t) -> u64;
}
extern "C" {
    #[doc = " Generate or recycle a new id."]
    pub fn flecs_sparse_new_id(sparse: *mut ecs_sparse_t) -> u64;
}
extern "C" {
    #[doc = " Remove an element"]
    pub fn flecs_sparse_remove(sparse: *mut ecs_sparse_t, elem_size: ecs_size_t, id: u64);
}
extern "C" {
    #[doc = " Remove an element without liveliness checking"]
    pub fn flecs_sparse_remove_fast(
        sparse: *mut ecs_sparse_t,
        size: ecs_size_t,
        index: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Test if id is alive, which requires the generation count to match."]
    pub fn flecs_sparse_is_alive(sparse: *const ecs_sparse_t, id: u64) -> bool;
}
extern "C" {
    #[doc = " Get value from sparse set by dense id. This function is useful in\n combination with flecs_sparse_count for iterating all values in the set."]
    pub fn flecs_sparse_get_dense(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the number of alive elements in the sparse set."]
    pub fn flecs_sparse_count(sparse: *const ecs_sparse_t) -> i32;
}
extern "C" {
    #[doc = " Get element by (sparse) id. The returned pointer is stable for the duration\n of the sparse set, as it is stored in the sparse array."]
    pub fn flecs_sparse_get(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Same as flecs_sparse_get, but doesn't assert if id is not alive."]
    pub fn flecs_sparse_try(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Like get_sparse, but don't care whether element is alive or not."]
    pub fn flecs_sparse_get_any(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get or create element by (sparse) id."]
    pub fn flecs_sparse_ensure(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Fast version of ensure, no liveliness checking"]
    pub fn flecs_sparse_ensure_fast(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get pointer to ids (alive and not alive). Use with count() or size()."]
    pub fn flecs_sparse_ids(sparse: *const ecs_sparse_t) -> *const u64;
}
extern "C" {
    pub fn ecs_sparse_init(sparse: *mut ecs_sparse_t, elem_size: ecs_size_t);
}
extern "C" {
    pub fn ecs_sparse_add(
        sparse: *mut ecs_sparse_t,
        elem_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_sparse_last_id(sparse: *const ecs_sparse_t) -> u64;
}
extern "C" {
    pub fn ecs_sparse_count(sparse: *const ecs_sparse_t) -> i32;
}
extern "C" {
    pub fn ecs_sparse_get_dense(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        index: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ecs_sparse_get(
        sparse: *const ecs_sparse_t,
        elem_size: ecs_size_t,
        id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_block_allocator_block_t {
    pub memory: *mut ::std::os::raw::c_void,
    pub next: *mut ecs_block_allocator_block_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_block_allocator_block_t"]
        [::std::mem::size_of::<ecs_block_allocator_block_t>() - 16usize];
    ["Alignment of ecs_block_allocator_block_t"]
        [::std::mem::align_of::<ecs_block_allocator_block_t>() - 8usize];
    ["Offset of field: ecs_block_allocator_block_t::memory"]
        [::std::mem::offset_of!(ecs_block_allocator_block_t, memory) - 0usize];
    ["Offset of field: ecs_block_allocator_block_t::next"]
        [::std::mem::offset_of!(ecs_block_allocator_block_t, next) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_block_allocator_chunk_header_t {
    pub next: *mut ecs_block_allocator_chunk_header_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_block_allocator_chunk_header_t"]
        [::std::mem::size_of::<ecs_block_allocator_chunk_header_t>() - 8usize];
    ["Alignment of ecs_block_allocator_chunk_header_t"]
        [::std::mem::align_of::<ecs_block_allocator_chunk_header_t>() - 8usize];
    ["Offset of field: ecs_block_allocator_chunk_header_t::next"]
        [::std::mem::offset_of!(ecs_block_allocator_chunk_header_t, next) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_block_allocator_t {
    pub head: *mut ecs_block_allocator_chunk_header_t,
    pub block_head: *mut ecs_block_allocator_block_t,
    pub block_tail: *mut ecs_block_allocator_block_t,
    pub chunk_size: i32,
    pub data_size: i32,
    pub chunks_per_block: i32,
    pub block_size: i32,
    pub alloc_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_block_allocator_t"][::std::mem::size_of::<ecs_block_allocator_t>() - 48usize];
    ["Alignment of ecs_block_allocator_t"]
        [::std::mem::align_of::<ecs_block_allocator_t>() - 8usize];
    ["Offset of field: ecs_block_allocator_t::head"]
        [::std::mem::offset_of!(ecs_block_allocator_t, head) - 0usize];
    ["Offset of field: ecs_block_allocator_t::block_head"]
        [::std::mem::offset_of!(ecs_block_allocator_t, block_head) - 8usize];
    ["Offset of field: ecs_block_allocator_t::block_tail"]
        [::std::mem::offset_of!(ecs_block_allocator_t, block_tail) - 16usize];
    ["Offset of field: ecs_block_allocator_t::chunk_size"]
        [::std::mem::offset_of!(ecs_block_allocator_t, chunk_size) - 24usize];
    ["Offset of field: ecs_block_allocator_t::data_size"]
        [::std::mem::offset_of!(ecs_block_allocator_t, data_size) - 28usize];
    ["Offset of field: ecs_block_allocator_t::chunks_per_block"]
        [::std::mem::offset_of!(ecs_block_allocator_t, chunks_per_block) - 32usize];
    ["Offset of field: ecs_block_allocator_t::block_size"]
        [::std::mem::offset_of!(ecs_block_allocator_t, block_size) - 36usize];
    ["Offset of field: ecs_block_allocator_t::alloc_count"]
        [::std::mem::offset_of!(ecs_block_allocator_t, alloc_count) - 40usize];
};
extern "C" {
    pub fn flecs_ballocator_init(ba: *mut ecs_block_allocator_t, size: ecs_size_t);
}
extern "C" {
    pub fn flecs_ballocator_new(size: ecs_size_t) -> *mut ecs_block_allocator_t;
}
extern "C" {
    pub fn flecs_ballocator_fini(ba: *mut ecs_block_allocator_t);
}
extern "C" {
    pub fn flecs_ballocator_free(ba: *mut ecs_block_allocator_t);
}
extern "C" {
    pub fn flecs_balloc(allocator: *mut ecs_block_allocator_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_bcalloc(allocator: *mut ecs_block_allocator_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_bfree(allocator: *mut ecs_block_allocator_t, memory: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn flecs_bfree_w_dbg_info(
        allocator: *mut ecs_block_allocator_t,
        memory: *mut ::std::os::raw::c_void,
        type_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn flecs_brealloc(
        dst: *mut ecs_block_allocator_t,
        src: *mut ecs_block_allocator_t,
        memory: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_bdup(
        ba: *mut ecs_block_allocator_t,
        memory: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stack_page_t {
    pub data: *mut ::std::os::raw::c_void,
    pub next: *mut ecs_stack_page_t,
    pub sp: i16,
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_stack_page_t"][::std::mem::size_of::<ecs_stack_page_t>() - 24usize];
    ["Alignment of ecs_stack_page_t"][::std::mem::align_of::<ecs_stack_page_t>() - 8usize];
    ["Offset of field: ecs_stack_page_t::data"]
        [::std::mem::offset_of!(ecs_stack_page_t, data) - 0usize];
    ["Offset of field: ecs_stack_page_t::next"]
        [::std::mem::offset_of!(ecs_stack_page_t, next) - 8usize];
    ["Offset of field: ecs_stack_page_t::sp"]
        [::std::mem::offset_of!(ecs_stack_page_t, sp) - 16usize];
    ["Offset of field: ecs_stack_page_t::id"]
        [::std::mem::offset_of!(ecs_stack_page_t, id) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stack_cursor_t {
    pub prev: *mut ecs_stack_cursor_t,
    pub page: *mut ecs_stack_page_t,
    pub sp: i16,
    pub is_free: bool,
    pub owner: *mut ecs_stack_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_stack_cursor_t"][::std::mem::size_of::<ecs_stack_cursor_t>() - 32usize];
    ["Alignment of ecs_stack_cursor_t"][::std::mem::align_of::<ecs_stack_cursor_t>() - 8usize];
    ["Offset of field: ecs_stack_cursor_t::prev"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, prev) - 0usize];
    ["Offset of field: ecs_stack_cursor_t::page"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, page) - 8usize];
    ["Offset of field: ecs_stack_cursor_t::sp"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, sp) - 16usize];
    ["Offset of field: ecs_stack_cursor_t::is_free"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, is_free) - 18usize];
    ["Offset of field: ecs_stack_cursor_t::owner"]
        [::std::mem::offset_of!(ecs_stack_cursor_t, owner) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stack_t {
    pub first: ecs_stack_page_t,
    pub tail_page: *mut ecs_stack_page_t,
    pub tail_cursor: *mut ecs_stack_cursor_t,
    pub cursor_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_stack_t"][::std::mem::size_of::<ecs_stack_t>() - 48usize];
    ["Alignment of ecs_stack_t"][::std::mem::align_of::<ecs_stack_t>() - 8usize];
    ["Offset of field: ecs_stack_t::first"][::std::mem::offset_of!(ecs_stack_t, first) - 0usize];
    ["Offset of field: ecs_stack_t::tail_page"]
        [::std::mem::offset_of!(ecs_stack_t, tail_page) - 24usize];
    ["Offset of field: ecs_stack_t::tail_cursor"]
        [::std::mem::offset_of!(ecs_stack_t, tail_cursor) - 32usize];
    ["Offset of field: ecs_stack_t::cursor_count"]
        [::std::mem::offset_of!(ecs_stack_t, cursor_count) - 40usize];
};
extern "C" {
    pub fn flecs_stack_init(stack: *mut ecs_stack_t);
}
extern "C" {
    pub fn flecs_stack_fini(stack: *mut ecs_stack_t);
}
extern "C" {
    pub fn flecs_stack_alloc(
        stack: *mut ecs_stack_t,
        size: ecs_size_t,
        align: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_stack_calloc(
        stack: *mut ecs_stack_t,
        size: ecs_size_t,
        align: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_stack_free(ptr: *mut ::std::os::raw::c_void, size: ecs_size_t);
}
extern "C" {
    pub fn flecs_stack_reset(stack: *mut ecs_stack_t);
}
extern "C" {
    pub fn flecs_stack_get_cursor(stack: *mut ecs_stack_t) -> *mut ecs_stack_cursor_t;
}
extern "C" {
    pub fn flecs_stack_restore_cursor(stack: *mut ecs_stack_t, cursor: *mut ecs_stack_cursor_t);
}
pub type ecs_map_data_t = u64;
pub type ecs_map_key_t = ecs_map_data_t;
pub type ecs_map_val_t = ecs_map_data_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bucket_entry_t {
    pub key: ecs_map_key_t,
    pub value: ecs_map_val_t,
    pub next: *mut ecs_bucket_entry_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_bucket_entry_t"][::std::mem::size_of::<ecs_bucket_entry_t>() - 24usize];
    ["Alignment of ecs_bucket_entry_t"][::std::mem::align_of::<ecs_bucket_entry_t>() - 8usize];
    ["Offset of field: ecs_bucket_entry_t::key"]
        [::std::mem::offset_of!(ecs_bucket_entry_t, key) - 0usize];
    ["Offset of field: ecs_bucket_entry_t::value"]
        [::std::mem::offset_of!(ecs_bucket_entry_t, value) - 8usize];
    ["Offset of field: ecs_bucket_entry_t::next"]
        [::std::mem::offset_of!(ecs_bucket_entry_t, next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bucket_t {
    pub first: *mut ecs_bucket_entry_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_bucket_t"][::std::mem::size_of::<ecs_bucket_t>() - 8usize];
    ["Alignment of ecs_bucket_t"][::std::mem::align_of::<ecs_bucket_t>() - 8usize];
    ["Offset of field: ecs_bucket_t::first"][::std::mem::offset_of!(ecs_bucket_t, first) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_map_t {
    pub bucket_shift: u8,
    pub shared_allocator: bool,
    pub buckets: *mut ecs_bucket_t,
    pub bucket_count: i32,
    pub count: i32,
    pub entry_allocator: *mut ecs_block_allocator_t,
    pub allocator: *mut ecs_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_map_t"][::std::mem::size_of::<ecs_map_t>() - 40usize];
    ["Alignment of ecs_map_t"][::std::mem::align_of::<ecs_map_t>() - 8usize];
    ["Offset of field: ecs_map_t::bucket_shift"]
        [::std::mem::offset_of!(ecs_map_t, bucket_shift) - 0usize];
    ["Offset of field: ecs_map_t::shared_allocator"]
        [::std::mem::offset_of!(ecs_map_t, shared_allocator) - 1usize];
    ["Offset of field: ecs_map_t::buckets"][::std::mem::offset_of!(ecs_map_t, buckets) - 8usize];
    ["Offset of field: ecs_map_t::bucket_count"]
        [::std::mem::offset_of!(ecs_map_t, bucket_count) - 16usize];
    ["Offset of field: ecs_map_t::count"][::std::mem::offset_of!(ecs_map_t, count) - 20usize];
    ["Offset of field: ecs_map_t::entry_allocator"]
        [::std::mem::offset_of!(ecs_map_t, entry_allocator) - 24usize];
    ["Offset of field: ecs_map_t::allocator"]
        [::std::mem::offset_of!(ecs_map_t, allocator) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_map_iter_t {
    pub map: *const ecs_map_t,
    pub bucket: *mut ecs_bucket_t,
    pub entry: *mut ecs_bucket_entry_t,
    pub res: *mut ecs_map_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_map_iter_t"][::std::mem::size_of::<ecs_map_iter_t>() - 32usize];
    ["Alignment of ecs_map_iter_t"][::std::mem::align_of::<ecs_map_iter_t>() - 8usize];
    ["Offset of field: ecs_map_iter_t::map"][::std::mem::offset_of!(ecs_map_iter_t, map) - 0usize];
    ["Offset of field: ecs_map_iter_t::bucket"]
        [::std::mem::offset_of!(ecs_map_iter_t, bucket) - 8usize];
    ["Offset of field: ecs_map_iter_t::entry"]
        [::std::mem::offset_of!(ecs_map_iter_t, entry) - 16usize];
    ["Offset of field: ecs_map_iter_t::res"][::std::mem::offset_of!(ecs_map_iter_t, res) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_map_params_t {
    pub allocator: *mut ecs_allocator_t,
    pub entry_allocator: ecs_block_allocator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_map_params_t"][::std::mem::size_of::<ecs_map_params_t>() - 56usize];
    ["Alignment of ecs_map_params_t"][::std::mem::align_of::<ecs_map_params_t>() - 8usize];
    ["Offset of field: ecs_map_params_t::allocator"]
        [::std::mem::offset_of!(ecs_map_params_t, allocator) - 0usize];
    ["Offset of field: ecs_map_params_t::entry_allocator"]
        [::std::mem::offset_of!(ecs_map_params_t, entry_allocator) - 8usize];
};
extern "C" {
    pub fn ecs_map_params_init(params: *mut ecs_map_params_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    pub fn ecs_map_params_fini(params: *mut ecs_map_params_t);
}
extern "C" {
    #[doc = " Initialize new map."]
    pub fn ecs_map_init(map: *mut ecs_map_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    #[doc = " Initialize new map."]
    pub fn ecs_map_init_w_params(map: *mut ecs_map_t, params: *mut ecs_map_params_t);
}
extern "C" {
    #[doc = " Initialize new map if uninitialized, leave as is otherwise"]
    pub fn ecs_map_init_if(map: *mut ecs_map_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    pub fn ecs_map_init_w_params_if(result: *mut ecs_map_t, params: *mut ecs_map_params_t);
}
extern "C" {
    #[doc = " Deinitialize map."]
    pub fn ecs_map_fini(map: *mut ecs_map_t);
}
extern "C" {
    #[doc = " Get element for key, returns NULL if they key doesn't exist."]
    pub fn ecs_map_get(map: *const ecs_map_t, key: ecs_map_key_t) -> *mut ecs_map_val_t;
}
extern "C" {
    pub fn ecs_map_get_deref_(
        map: *const ecs_map_t,
        key: ecs_map_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get or insert element for key."]
    pub fn ecs_map_ensure(map: *mut ecs_map_t, key: ecs_map_key_t) -> *mut ecs_map_val_t;
}
extern "C" {
    #[doc = " Get or insert pointer element for key, allocate if the pointer is NULL"]
    pub fn ecs_map_ensure_alloc(
        map: *mut ecs_map_t,
        elem_size: ecs_size_t,
        key: ecs_map_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Insert element for key."]
    pub fn ecs_map_insert(map: *mut ecs_map_t, key: ecs_map_key_t, value: ecs_map_val_t);
}
extern "C" {
    #[doc = " Insert pointer element for key, populate with new allocation."]
    pub fn ecs_map_insert_alloc(
        map: *mut ecs_map_t,
        elem_size: ecs_size_t,
        key: ecs_map_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Remove key from map."]
    pub fn ecs_map_remove(map: *mut ecs_map_t, key: ecs_map_key_t) -> ecs_map_val_t;
}
extern "C" {
    pub fn ecs_map_remove_free(map: *mut ecs_map_t, key: ecs_map_key_t);
}
extern "C" {
    #[doc = " Remove all elements from map."]
    pub fn ecs_map_clear(map: *mut ecs_map_t);
}
extern "C" {
    #[doc = " Return iterator to map contents."]
    pub fn ecs_map_iter(map: *const ecs_map_t) -> ecs_map_iter_t;
}
extern "C" {
    #[doc = " Obtain next element in map from iterator."]
    pub fn ecs_map_next(iter: *mut ecs_map_iter_t) -> bool;
}
extern "C" {
    #[doc = " Copy map."]
    pub fn ecs_map_copy(dst: *mut ecs_map_t, src: *const ecs_map_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_switch_node_t {
    pub next: u32,
    pub prev: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_switch_node_t"][::std::mem::size_of::<ecs_switch_node_t>() - 8usize];
    ["Alignment of ecs_switch_node_t"][::std::mem::align_of::<ecs_switch_node_t>() - 4usize];
    ["Offset of field: ecs_switch_node_t::next"]
        [::std::mem::offset_of!(ecs_switch_node_t, next) - 0usize];
    ["Offset of field: ecs_switch_node_t::prev"]
        [::std::mem::offset_of!(ecs_switch_node_t, prev) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_switch_page_t {
    pub nodes: ecs_vec_t,
    pub values: ecs_vec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_switch_page_t"][::std::mem::size_of::<ecs_switch_page_t>() - 32usize];
    ["Alignment of ecs_switch_page_t"][::std::mem::align_of::<ecs_switch_page_t>() - 8usize];
    ["Offset of field: ecs_switch_page_t::nodes"]
        [::std::mem::offset_of!(ecs_switch_page_t, nodes) - 0usize];
    ["Offset of field: ecs_switch_page_t::values"]
        [::std::mem::offset_of!(ecs_switch_page_t, values) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_switch_t {
    pub hdrs: ecs_map_t,
    pub pages: ecs_vec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_switch_t"][::std::mem::size_of::<ecs_switch_t>() - 56usize];
    ["Alignment of ecs_switch_t"][::std::mem::align_of::<ecs_switch_t>() - 8usize];
    ["Offset of field: ecs_switch_t::hdrs"][::std::mem::offset_of!(ecs_switch_t, hdrs) - 0usize];
    ["Offset of field: ecs_switch_t::pages"][::std::mem::offset_of!(ecs_switch_t, pages) - 40usize];
};
extern "C" {
    #[doc = " Init new switch."]
    pub fn flecs_switch_init(sw: *mut ecs_switch_t, allocator: *mut ecs_allocator_t);
}
extern "C" {
    #[doc = " Fini switch."]
    pub fn flecs_switch_fini(sw: *mut ecs_switch_t);
}
extern "C" {
    #[doc = " Set value of element."]
    pub fn flecs_switch_set(sw: *mut ecs_switch_t, element: u32, value: u64) -> bool;
}
extern "C" {
    #[doc = " Reset value of element."]
    pub fn flecs_switch_reset(sw: *mut ecs_switch_t, element: u32) -> bool;
}
extern "C" {
    #[doc = " Get value for element."]
    pub fn flecs_switch_get(sw: *const ecs_switch_t, element: u32) -> u64;
}
extern "C" {
    #[doc = " Get first element for value."]
    pub fn flecs_switch_first(sw: *const ecs_switch_t, value: u64) -> u32;
}
extern "C" {
    #[doc = " Get next element."]
    pub fn flecs_switch_next(sw: *const ecs_switch_t, previous: u32) -> u32;
}
extern "C" {
    #[doc = " Get target iterator."]
    pub fn flecs_switch_targets(sw: *const ecs_switch_t) -> ecs_map_iter_t;
}
extern "C" {
    pub static mut ecs_block_allocator_alloc_count: i64;
}
extern "C" {
    pub static mut ecs_block_allocator_free_count: i64;
}
extern "C" {
    pub static mut ecs_stack_allocator_alloc_count: i64;
}
extern "C" {
    pub static mut ecs_stack_allocator_free_count: i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_allocator_t {
    pub chunks: ecs_block_allocator_t,
    pub sizes: ecs_sparse_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_allocator_t"][::std::mem::size_of::<ecs_allocator_t>() - 112usize];
    ["Alignment of ecs_allocator_t"][::std::mem::align_of::<ecs_allocator_t>() - 8usize];
    ["Offset of field: ecs_allocator_t::chunks"]
        [::std::mem::offset_of!(ecs_allocator_t, chunks) - 0usize];
    ["Offset of field: ecs_allocator_t::sizes"]
        [::std::mem::offset_of!(ecs_allocator_t, sizes) - 48usize];
};
extern "C" {
    pub fn flecs_allocator_init(a: *mut ecs_allocator_t);
}
extern "C" {
    pub fn flecs_allocator_fini(a: *mut ecs_allocator_t);
}
extern "C" {
    pub fn flecs_allocator_get(
        a: *mut ecs_allocator_t,
        size: ecs_size_t,
    ) -> *mut ecs_block_allocator_t;
}
extern "C" {
    pub fn flecs_strdup(
        a: *mut ecs_allocator_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_strfree(a: *mut ecs_allocator_t, str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn flecs_dup(
        a: *mut ecs_allocator_t,
        size: ecs_size_t,
        src: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_strbuf_list_elem {
    pub count: i32,
    pub separator: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_strbuf_list_elem"][::std::mem::size_of::<ecs_strbuf_list_elem>() - 16usize];
    ["Alignment of ecs_strbuf_list_elem"][::std::mem::align_of::<ecs_strbuf_list_elem>() - 8usize];
    ["Offset of field: ecs_strbuf_list_elem::count"]
        [::std::mem::offset_of!(ecs_strbuf_list_elem, count) - 0usize];
    ["Offset of field: ecs_strbuf_list_elem::separator"]
        [::std::mem::offset_of!(ecs_strbuf_list_elem, separator) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_strbuf_t {
    pub content: *mut ::std::os::raw::c_char,
    pub length: ecs_size_t,
    pub size: ecs_size_t,
    pub list_stack: [ecs_strbuf_list_elem; 32usize],
    pub list_sp: i32,
    pub small_string: [::std::os::raw::c_char; 512usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_strbuf_t"][::std::mem::size_of::<ecs_strbuf_t>() - 1048usize];
    ["Alignment of ecs_strbuf_t"][::std::mem::align_of::<ecs_strbuf_t>() - 8usize];
    ["Offset of field: ecs_strbuf_t::content"]
        [::std::mem::offset_of!(ecs_strbuf_t, content) - 0usize];
    ["Offset of field: ecs_strbuf_t::length"]
        [::std::mem::offset_of!(ecs_strbuf_t, length) - 8usize];
    ["Offset of field: ecs_strbuf_t::size"][::std::mem::offset_of!(ecs_strbuf_t, size) - 12usize];
    ["Offset of field: ecs_strbuf_t::list_stack"]
        [::std::mem::offset_of!(ecs_strbuf_t, list_stack) - 16usize];
    ["Offset of field: ecs_strbuf_t::list_sp"]
        [::std::mem::offset_of!(ecs_strbuf_t, list_sp) - 528usize];
    ["Offset of field: ecs_strbuf_t::small_string"]
        [::std::mem::offset_of!(ecs_strbuf_t, small_string) - 532usize];
};
extern "C" {
    pub fn ecs_strbuf_append(buffer: *mut ecs_strbuf_t, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn ecs_strbuf_vappend(
        buffer: *mut ecs_strbuf_t,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn ecs_strbuf_appendstr(buffer: *mut ecs_strbuf_t, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ecs_strbuf_appendch(buffer: *mut ecs_strbuf_t, ch: ::std::os::raw::c_char);
}
extern "C" {
    pub fn ecs_strbuf_appendint(buffer: *mut ecs_strbuf_t, v: i64);
}
extern "C" {
    pub fn ecs_strbuf_appendflt(
        buffer: *mut ecs_strbuf_t,
        v: f64,
        nan_delim: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_strbuf_appendbool(buffer: *mut ecs_strbuf_t, v: bool);
}
extern "C" {
    pub fn ecs_strbuf_mergebuff(dst_buffer: *mut ecs_strbuf_t, src_buffer: *mut ecs_strbuf_t);
}
extern "C" {
    pub fn ecs_strbuf_appendstrn(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
        n: i32,
    );
}
extern "C" {
    pub fn ecs_strbuf_get(buffer: *mut ecs_strbuf_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_strbuf_get_small(buffer: *mut ecs_strbuf_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecs_strbuf_reset(buffer: *mut ecs_strbuf_t);
}
extern "C" {
    pub fn ecs_strbuf_list_push(
        buffer: *mut ecs_strbuf_t,
        list_open: *const ::std::os::raw::c_char,
        separator: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_strbuf_list_pop(
        buffer: *mut ecs_strbuf_t,
        list_close: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_strbuf_list_next(buffer: *mut ecs_strbuf_t);
}
extern "C" {
    pub fn ecs_strbuf_list_appendch(buffer: *mut ecs_strbuf_t, ch: ::std::os::raw::c_char);
}
extern "C" {
    pub fn ecs_strbuf_list_append(
        buffer: *mut ecs_strbuf_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_strbuf_list_appendstr(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ecs_strbuf_list_appendstrn(
        buffer: *mut ecs_strbuf_t,
        str_: *const ::std::os::raw::c_char,
        n: i32,
    );
}
extern "C" {
    pub fn ecs_strbuf_written(buffer: *const ecs_strbuf_t) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _iobuf {
    pub _Placeholder: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _iobuf"][::std::mem::size_of::<_iobuf>() - 8usize];
    ["Alignment of _iobuf"][::std::mem::align_of::<_iobuf>() - 8usize];
    ["Offset of field: _iobuf::_Placeholder"]
        [::std::mem::offset_of!(_iobuf, _Placeholder) - 0usize];
};
pub type FILE = _iobuf;
extern "C" {
    pub fn __acrt_iob_func(_Ix: ::std::os::raw::c_uint) -> *mut FILE;
}
extern "C" {
    pub fn fgetwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fgetwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn getwc(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fgetws(
        _Buffer: *mut wchar_t,
        _BufferCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(_Buffer: *const wchar_t, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getws_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn putwc(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(_Character: wchar_t) -> wint_t;
}
extern "C" {
    pub fn _putws(_Buffer: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _wfdopen(_FileHandle: ::std::os::raw::c_int, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen(_FileName: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wfopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfreopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wfreopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn _wfsopen(
        _FileName: *const wchar_t,
        _Mode: *const wchar_t,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wpopen(_Command: *const wchar_t, _Mode: *const wchar_t) -> *mut FILE;
}
extern "C" {
    pub fn _wremove(_FileName: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtempnam(_Directory: *const wchar_t, _FilePrefix: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtmpnam_s(_Buffer: *mut wchar_t, _BufferCount: usize) -> errno_t;
}
extern "C" {
    pub fn _wtmpnam(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _fgetwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _fputwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _getwc_nolock(_Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _putwc_nolock(_Character: wchar_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn _ungetwc_nolock(_Character: wint_t, _Stream: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn __stdio_common_vfwprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfwscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnwprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vswscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const wchar_t,
        _BufferCount: usize,
        _Format: *const wchar_t,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = ::std::os::raw::c_longlong;
extern "C" {
    pub fn _get_stream_buffer_pointers(
        _Stream: *mut FILE,
        _Base: *mut *mut *mut ::std::os::raw::c_char,
        _Pointer: *mut *mut *mut ::std::os::raw::c_char,
        _Count: *mut *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn clearerr_s(_Stream: *mut FILE) -> errno_t;
}
extern "C" {
    pub fn fopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn fread_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen_s(
        _Stream: *mut *mut FILE,
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _OldStream: *mut FILE,
    ) -> errno_t;
}
extern "C" {
    pub fn gets_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _Size: rsize_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile_s(_Stream: *mut *mut FILE) -> errno_t;
}
extern "C" {
    pub fn tmpnam_s(_Buffer: *mut ::std::os::raw::c_char, _Size: rsize_t) -> errno_t;
}
extern "C" {
    pub fn clearerr(_Stream: *mut FILE);
}
extern "C" {
    pub fn fclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn feof(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(_Stream: *mut FILE, _Position: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fputc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(
        _Buffer: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn freopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _Stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fsopen(
        _FileName: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
        _ShFlag: ::std::os::raw::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fsetpos(_Stream: *mut FILE, _Position: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fwrite(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: ::std::os::raw::c_ulonglong,
        _ElementCount: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn getc(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getmaxstdio() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrorMessage: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn _pclose(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _popen(
        _Command: *const ::std::os::raw::c_char,
        _Mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn putc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(_Character: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(_Buffer: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putw(_Word: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        _OldFileName: *const ::std::os::raw::c_char,
        _NewFileName: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(_FileName: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(_Stream: *mut FILE);
}
extern "C" {
    pub fn _rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(_Stream: *mut FILE, _Buffer: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn _setmaxstdio(_Maximum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setvbuf(
        _Stream: *mut FILE,
        _Buffer: *mut ::std::os::raw::c_char,
        _Mode: ::std::os::raw::c_int,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tempnam(
        _DirectoryName: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(_Character: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _lock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _unlock_file(_Stream: *mut FILE);
}
extern "C" {
    pub fn _fclose_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fflush_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fgetc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fputc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fread_nolock(
        _Buffer: *mut ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_nolock_s(
        _Buffer: *mut ::std::os::raw::c_void,
        _BufferSize: usize,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fseek_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_long,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _fseeki64_nolock(
        _Stream: *mut FILE,
        _Offset: ::std::os::raw::c_longlong,
        _Origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ftell_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _ftelli64_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _fwrite_nolock(
        _Buffer: *const ::std::os::raw::c_void,
        _ElementSize: usize,
        _ElementCount: usize,
        _Stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_nolock(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ungetc_nolock(
        _Character: ::std::os::raw::c_int,
        _Stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p__commode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_printf_count_output(_Value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_printf_count_output() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vfscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Stream: *mut FILE,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _Arglist: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsnprintf_s(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _MaxCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsprintf_p(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __stdio_common_vsscanf(
        _Options: ::std::os::raw::c_ulonglong,
        _Buffer: *const ::std::os::raw::c_char,
        _BufferCount: usize,
        _Format: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
        _ArgList: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        _Directory: *const ::std::os::raw::c_char,
        _FilePrefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdopen(
        _FileHandle: ::std::os::raw::c_int,
        _Format: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fgetchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flushall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputchar(_Ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(_Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(_Ch: ::std::os::raw::c_int, _Stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtmp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _heapinfo"][::std::mem::size_of::<_heapinfo>() - 24usize];
    ["Alignment of _heapinfo"][::std::mem::align_of::<_heapinfo>() - 8usize];
    ["Offset of field: _heapinfo::_pentry"][::std::mem::offset_of!(_heapinfo, _pentry) - 0usize];
    ["Offset of field: _heapinfo::_size"][::std::mem::offset_of!(_heapinfo, _size) - 8usize];
    ["Offset of field: _heapinfo::_useflag"][::std::mem::offset_of!(_heapinfo, _useflag) - 16usize];
};
pub type _HEAPINFO = _heapinfo;
extern "C" {
    pub fn _alloca(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
#[doc = " Time type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_time_t {
    #[doc = "< Second part."]
    pub sec: u32,
    #[doc = "< Nanosecond part."]
    pub nanosec: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_time_t"][::std::mem::size_of::<ecs_time_t>() - 8usize];
    ["Alignment of ecs_time_t"][::std::mem::align_of::<ecs_time_t>() - 4usize];
    ["Offset of field: ecs_time_t::sec"][::std::mem::offset_of!(ecs_time_t, sec) - 0usize];
    ["Offset of field: ecs_time_t::nanosec"][::std::mem::offset_of!(ecs_time_t, nanosec) - 4usize];
};
extern "C" {
    #[doc = "< malloc count."]
    pub static mut ecs_os_api_malloc_count: i64;
}
extern "C" {
    #[doc = "< realloc count."]
    pub static mut ecs_os_api_realloc_count: i64;
}
extern "C" {
    #[doc = "< calloc count."]
    pub static mut ecs_os_api_calloc_count: i64;
}
extern "C" {
    #[doc = "< free count."]
    pub static mut ecs_os_api_free_count: i64;
}
pub type ecs_os_thread_t = usize;
pub type ecs_os_cond_t = usize;
pub type ecs_os_mutex_t = usize;
pub type ecs_os_dl_t = usize;
pub type ecs_os_sock_t = usize;
#[doc = " 64 bit thread id."]
pub type ecs_os_thread_id_t = u64;
#[doc = " Generic function pointer type."]
pub type ecs_os_proc_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " OS API init."]
pub type ecs_os_api_init_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " OS API deinit."]
pub type ecs_os_api_fini_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " OS API malloc function type."]
pub type ecs_os_api_malloc_t =
    ::std::option::Option<unsafe extern "C" fn(size: ecs_size_t) -> *mut ::std::os::raw::c_void>;
#[doc = " OS API free function type."]
pub type ecs_os_api_free_t =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
#[doc = " OS API realloc function type."]
pub type ecs_os_api_realloc_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " OS API calloc function type."]
pub type ecs_os_api_calloc_t =
    ::std::option::Option<unsafe extern "C" fn(size: ecs_size_t) -> *mut ::std::os::raw::c_void>;
#[doc = " OS API strdup function type."]
pub type ecs_os_api_strdup_t = ::std::option::Option<
    unsafe extern "C" fn(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
#[doc = " OS API thread_callback function type."]
pub type ecs_os_thread_callback_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
#[doc = " OS API thread_new function type."]
pub type ecs_os_api_thread_new_t = ::std::option::Option<
    unsafe extern "C" fn(
        callback: ecs_os_thread_callback_t,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_os_thread_t,
>;
#[doc = " OS API thread_join function type."]
pub type ecs_os_api_thread_join_t = ::std::option::Option<
    unsafe extern "C" fn(thread: ecs_os_thread_t) -> *mut ::std::os::raw::c_void,
>;
#[doc = " OS API thread_self function type."]
pub type ecs_os_api_thread_self_t =
    ::std::option::Option<unsafe extern "C" fn() -> ecs_os_thread_id_t>;
#[doc = " OS API task_new function type."]
pub type ecs_os_api_task_new_t = ::std::option::Option<
    unsafe extern "C" fn(
        callback: ecs_os_thread_callback_t,
        param: *mut ::std::os::raw::c_void,
    ) -> ecs_os_thread_t,
>;
#[doc = " OS API task_join function type."]
pub type ecs_os_api_task_join_t = ::std::option::Option<
    unsafe extern "C" fn(thread: ecs_os_thread_t) -> *mut ::std::os::raw::c_void,
>;
#[doc = " OS API ainc function type."]
pub type ecs_os_api_ainc_t = ::std::option::Option<unsafe extern "C" fn(value: *mut i32) -> i32>;
#[doc = " OS API lainc function type."]
pub type ecs_os_api_lainc_t = ::std::option::Option<unsafe extern "C" fn(value: *mut i64) -> i64>;
#[doc = " OS API mutex_new function type."]
pub type ecs_os_api_mutex_new_t = ::std::option::Option<unsafe extern "C" fn() -> ecs_os_mutex_t>;
#[doc = " OS API mutex_lock function type."]
pub type ecs_os_api_mutex_lock_t =
    ::std::option::Option<unsafe extern "C" fn(mutex: ecs_os_mutex_t)>;
#[doc = " OS API mutex_unlock function type."]
pub type ecs_os_api_mutex_unlock_t =
    ::std::option::Option<unsafe extern "C" fn(mutex: ecs_os_mutex_t)>;
#[doc = " OS API mutex_free function type."]
pub type ecs_os_api_mutex_free_t =
    ::std::option::Option<unsafe extern "C" fn(mutex: ecs_os_mutex_t)>;
#[doc = " OS API cond_new function type."]
pub type ecs_os_api_cond_new_t = ::std::option::Option<unsafe extern "C" fn() -> ecs_os_cond_t>;
#[doc = " OS API cond_free function type."]
pub type ecs_os_api_cond_free_t = ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t)>;
#[doc = " OS API cond_signal function type."]
pub type ecs_os_api_cond_signal_t =
    ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t)>;
#[doc = " OS API cond_broadcast function type."]
pub type ecs_os_api_cond_broadcast_t =
    ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t)>;
#[doc = " OS API cond_wait function type."]
pub type ecs_os_api_cond_wait_t =
    ::std::option::Option<unsafe extern "C" fn(cond: ecs_os_cond_t, mutex: ecs_os_mutex_t)>;
#[doc = " OS API sleep function type."]
pub type ecs_os_api_sleep_t = ::std::option::Option<unsafe extern "C" fn(sec: i32, nanosec: i32)>;
#[doc = " OS API enable_high_timer_resolution function type."]
pub type ecs_os_api_enable_high_timer_resolution_t =
    ::std::option::Option<unsafe extern "C" fn(enable: bool)>;
#[doc = " OS API get_time function type."]
pub type ecs_os_api_get_time_t =
    ::std::option::Option<unsafe extern "C" fn(time_out: *mut ecs_time_t)>;
#[doc = " OS API now function type."]
pub type ecs_os_api_now_t = ::std::option::Option<unsafe extern "C" fn() -> u64>;
#[doc = " OS API log function type."]
pub type ecs_os_api_log_t = ::std::option::Option<
    unsafe extern "C" fn(
        level: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " OS API abort function type."]
pub type ecs_os_api_abort_t = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " OS API dlopen function type."]
pub type ecs_os_api_dlopen_t = ::std::option::Option<
    unsafe extern "C" fn(libname: *const ::std::os::raw::c_char) -> ecs_os_dl_t,
>;
#[doc = " OS API dlproc function type."]
pub type ecs_os_api_dlproc_t = ::std::option::Option<
    unsafe extern "C" fn(
        lib: ecs_os_dl_t,
        procname: *const ::std::os::raw::c_char,
    ) -> ecs_os_proc_t,
>;
#[doc = " OS API dlclose function type."]
pub type ecs_os_api_dlclose_t = ::std::option::Option<unsafe extern "C" fn(lib: ecs_os_dl_t)>;
#[doc = " OS API module_to_path function type."]
pub type ecs_os_api_module_to_path_t = ::std::option::Option<
    unsafe extern "C" fn(module_id: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
>;
#[doc = " OS API interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_os_api_t {
    #[doc = "< init callback."]
    pub init_: ecs_os_api_init_t,
    #[doc = "< fini callback."]
    pub fini_: ecs_os_api_fini_t,
    #[doc = "< malloc callback."]
    pub malloc_: ecs_os_api_malloc_t,
    #[doc = "< realloc callback."]
    pub realloc_: ecs_os_api_realloc_t,
    #[doc = "< calloc callback."]
    pub calloc_: ecs_os_api_calloc_t,
    #[doc = "< free callback."]
    pub free_: ecs_os_api_free_t,
    #[doc = "< strdup callback."]
    pub strdup_: ecs_os_api_strdup_t,
    #[doc = "< thread_new callback."]
    pub thread_new_: ecs_os_api_thread_new_t,
    #[doc = "< thread_join callback."]
    pub thread_join_: ecs_os_api_thread_join_t,
    #[doc = "< thread_self callback."]
    pub thread_self_: ecs_os_api_thread_self_t,
    #[doc = "< task_new callback."]
    pub task_new_: ecs_os_api_thread_new_t,
    #[doc = "< task_join callback."]
    pub task_join_: ecs_os_api_thread_join_t,
    #[doc = "< ainc callback."]
    pub ainc_: ecs_os_api_ainc_t,
    #[doc = "< adec callback."]
    pub adec_: ecs_os_api_ainc_t,
    #[doc = "< lainc callback."]
    pub lainc_: ecs_os_api_lainc_t,
    #[doc = "< ladec callback."]
    pub ladec_: ecs_os_api_lainc_t,
    #[doc = "< mutex_new callback."]
    pub mutex_new_: ecs_os_api_mutex_new_t,
    #[doc = "< mutex_free callback."]
    pub mutex_free_: ecs_os_api_mutex_free_t,
    #[doc = "< mutex_lock callback."]
    pub mutex_lock_: ecs_os_api_mutex_lock_t,
    #[doc = "< mutex_unlock callback."]
    pub mutex_unlock_: ecs_os_api_mutex_lock_t,
    #[doc = "< cond_new callback."]
    pub cond_new_: ecs_os_api_cond_new_t,
    #[doc = "< cond_free callback."]
    pub cond_free_: ecs_os_api_cond_free_t,
    #[doc = "< cond_signal callback."]
    pub cond_signal_: ecs_os_api_cond_signal_t,
    #[doc = "< cond_broadcast callback."]
    pub cond_broadcast_: ecs_os_api_cond_broadcast_t,
    #[doc = "< cond_wait callback."]
    pub cond_wait_: ecs_os_api_cond_wait_t,
    #[doc = "< sleep callback."]
    pub sleep_: ecs_os_api_sleep_t,
    #[doc = "< now callback."]
    pub now_: ecs_os_api_now_t,
    #[doc = "< get_time callback."]
    pub get_time_: ecs_os_api_get_time_t,
    #[doc = "< log callback.\n The level should be interpreted as:\n >0: Debug tracing. Only enabled in debug builds.\n  0: Tracing. Enabled in debug/release builds.\n -2: Warning. An issue occurred, but operation was successful.\n -3: Error. An issue occurred, and operation was unsuccessful.\n -4: Fatal. An issue occurred, and application must quit."]
    pub log_: ecs_os_api_log_t,
    #[doc = "< abort callback."]
    pub abort_: ecs_os_api_abort_t,
    #[doc = "< dlopen callback."]
    pub dlopen_: ecs_os_api_dlopen_t,
    #[doc = "< dlproc callback."]
    pub dlproc_: ecs_os_api_dlproc_t,
    #[doc = "< dlclose callback."]
    pub dlclose_: ecs_os_api_dlclose_t,
    #[doc = "< module_to_dl callback."]
    pub module_to_dl_: ecs_os_api_module_to_path_t,
    #[doc = "< module_to_etc callback."]
    pub module_to_etc_: ecs_os_api_module_to_path_t,
    #[doc = "< Tracing level."]
    pub log_level_: i32,
    #[doc = "< Tracing indentation level."]
    pub log_indent_: i32,
    #[doc = "< Last logged error code."]
    pub log_last_error_: i32,
    #[doc = "< Last logged timestamp."]
    pub log_last_timestamp_: i64,
    #[doc = "< OS API flags"]
    pub flags_: ecs_flags32_t,
    #[doc = "< File used for logging output\n (hint, log_ decides where to write)"]
    pub log_out_: *mut FILE,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_os_api_t"][::std::mem::size_of::<ecs_os_api_t>() - 320usize];
    ["Alignment of ecs_os_api_t"][::std::mem::align_of::<ecs_os_api_t>() - 8usize];
    ["Offset of field: ecs_os_api_t::init_"][::std::mem::offset_of!(ecs_os_api_t, init_) - 0usize];
    ["Offset of field: ecs_os_api_t::fini_"][::std::mem::offset_of!(ecs_os_api_t, fini_) - 8usize];
    ["Offset of field: ecs_os_api_t::malloc_"]
        [::std::mem::offset_of!(ecs_os_api_t, malloc_) - 16usize];
    ["Offset of field: ecs_os_api_t::realloc_"]
        [::std::mem::offset_of!(ecs_os_api_t, realloc_) - 24usize];
    ["Offset of field: ecs_os_api_t::calloc_"]
        [::std::mem::offset_of!(ecs_os_api_t, calloc_) - 32usize];
    ["Offset of field: ecs_os_api_t::free_"][::std::mem::offset_of!(ecs_os_api_t, free_) - 40usize];
    ["Offset of field: ecs_os_api_t::strdup_"]
        [::std::mem::offset_of!(ecs_os_api_t, strdup_) - 48usize];
    ["Offset of field: ecs_os_api_t::thread_new_"]
        [::std::mem::offset_of!(ecs_os_api_t, thread_new_) - 56usize];
    ["Offset of field: ecs_os_api_t::thread_join_"]
        [::std::mem::offset_of!(ecs_os_api_t, thread_join_) - 64usize];
    ["Offset of field: ecs_os_api_t::thread_self_"]
        [::std::mem::offset_of!(ecs_os_api_t, thread_self_) - 72usize];
    ["Offset of field: ecs_os_api_t::task_new_"]
        [::std::mem::offset_of!(ecs_os_api_t, task_new_) - 80usize];
    ["Offset of field: ecs_os_api_t::task_join_"]
        [::std::mem::offset_of!(ecs_os_api_t, task_join_) - 88usize];
    ["Offset of field: ecs_os_api_t::ainc_"][::std::mem::offset_of!(ecs_os_api_t, ainc_) - 96usize];
    ["Offset of field: ecs_os_api_t::adec_"]
        [::std::mem::offset_of!(ecs_os_api_t, adec_) - 104usize];
    ["Offset of field: ecs_os_api_t::lainc_"]
        [::std::mem::offset_of!(ecs_os_api_t, lainc_) - 112usize];
    ["Offset of field: ecs_os_api_t::ladec_"]
        [::std::mem::offset_of!(ecs_os_api_t, ladec_) - 120usize];
    ["Offset of field: ecs_os_api_t::mutex_new_"]
        [::std::mem::offset_of!(ecs_os_api_t, mutex_new_) - 128usize];
    ["Offset of field: ecs_os_api_t::mutex_free_"]
        [::std::mem::offset_of!(ecs_os_api_t, mutex_free_) - 136usize];
    ["Offset of field: ecs_os_api_t::mutex_lock_"]
        [::std::mem::offset_of!(ecs_os_api_t, mutex_lock_) - 144usize];
    ["Offset of field: ecs_os_api_t::mutex_unlock_"]
        [::std::mem::offset_of!(ecs_os_api_t, mutex_unlock_) - 152usize];
    ["Offset of field: ecs_os_api_t::cond_new_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_new_) - 160usize];
    ["Offset of field: ecs_os_api_t::cond_free_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_free_) - 168usize];
    ["Offset of field: ecs_os_api_t::cond_signal_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_signal_) - 176usize];
    ["Offset of field: ecs_os_api_t::cond_broadcast_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_broadcast_) - 184usize];
    ["Offset of field: ecs_os_api_t::cond_wait_"]
        [::std::mem::offset_of!(ecs_os_api_t, cond_wait_) - 192usize];
    ["Offset of field: ecs_os_api_t::sleep_"]
        [::std::mem::offset_of!(ecs_os_api_t, sleep_) - 200usize];
    ["Offset of field: ecs_os_api_t::now_"][::std::mem::offset_of!(ecs_os_api_t, now_) - 208usize];
    ["Offset of field: ecs_os_api_t::get_time_"]
        [::std::mem::offset_of!(ecs_os_api_t, get_time_) - 216usize];
    ["Offset of field: ecs_os_api_t::log_"][::std::mem::offset_of!(ecs_os_api_t, log_) - 224usize];
    ["Offset of field: ecs_os_api_t::abort_"]
        [::std::mem::offset_of!(ecs_os_api_t, abort_) - 232usize];
    ["Offset of field: ecs_os_api_t::dlopen_"]
        [::std::mem::offset_of!(ecs_os_api_t, dlopen_) - 240usize];
    ["Offset of field: ecs_os_api_t::dlproc_"]
        [::std::mem::offset_of!(ecs_os_api_t, dlproc_) - 248usize];
    ["Offset of field: ecs_os_api_t::dlclose_"]
        [::std::mem::offset_of!(ecs_os_api_t, dlclose_) - 256usize];
    ["Offset of field: ecs_os_api_t::module_to_dl_"]
        [::std::mem::offset_of!(ecs_os_api_t, module_to_dl_) - 264usize];
    ["Offset of field: ecs_os_api_t::module_to_etc_"]
        [::std::mem::offset_of!(ecs_os_api_t, module_to_etc_) - 272usize];
    ["Offset of field: ecs_os_api_t::log_level_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_level_) - 280usize];
    ["Offset of field: ecs_os_api_t::log_indent_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_indent_) - 284usize];
    ["Offset of field: ecs_os_api_t::log_last_error_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_last_error_) - 288usize];
    ["Offset of field: ecs_os_api_t::log_last_timestamp_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_last_timestamp_) - 296usize];
    ["Offset of field: ecs_os_api_t::flags_"]
        [::std::mem::offset_of!(ecs_os_api_t, flags_) - 304usize];
    ["Offset of field: ecs_os_api_t::log_out_"]
        [::std::mem::offset_of!(ecs_os_api_t, log_out_) - 312usize];
};
extern "C" {
    #[doc = " Static OS API variable with configured callbacks."]
    pub static mut ecs_os_api: ecs_os_api_t;
}
extern "C" {
    #[doc = " Initialize OS API.\n This operation is not usually called by an application. To override callbacks\n of the OS API, use the following pattern:\n\n @code\n ecs_os_set_api_defaults();\n ecs_os_api_t os_api = ecs_os_get_api();\n os_api.abort_ = my_abort;\n ecs_os_set_api(&os_api);\n @endcode"]
    pub fn ecs_os_init();
}
extern "C" {
    #[doc = " Deinitialize OS API.\n This operation is not usually called by an application."]
    pub fn ecs_os_fini();
}
extern "C" {
    #[doc = " Override OS API.\n This overrides the OS API struct with new values for callbacks. See\n ecs_os_init() on how to use the function.\n\n @param os_api Pointer to struct with values to set."]
    pub fn ecs_os_set_api(os_api: *mut ecs_os_api_t);
}
extern "C" {
    #[doc = " Get OS API.\n\n @return A value with the current OS API callbacks\n @see ecs_os_init()"]
    pub fn ecs_os_get_api() -> ecs_os_api_t;
}
extern "C" {
    #[doc = " Set default values for OS API.\n This initializes the OS API struct with default values for callbacks like\n malloc and free.\n\n @see ecs_os_init()"]
    pub fn ecs_os_set_api_defaults();
}
extern "C" {
    #[doc = " Log at debug level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_dbg(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Log at trace level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_trace(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Log at warning level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_warn(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Log at error level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_err(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Log at fatal level.\n\n @param file The file to log.\n @param line The line to log.\n @param msg The message to log."]
    pub fn ecs_os_fatal(
        file: *const ::std::os::raw::c_char,
        line: i32,
        msg: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Convert errno to string.\n\n @param err The error number.\n @return A string describing the error."]
    pub fn ecs_os_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Utility for assigning strings.\n This operation frees an existing string and duplicates the input string.\n\n @param str Pointer to a string value.\n @param value The string value to assign."]
    pub fn ecs_os_strset(
        str_: *mut *mut ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Sleep with floating point time.\n\n @param t The time in seconds."]
    pub fn ecs_sleepf(t: f64);
}
extern "C" {
    #[doc = " Measure time since provided timestamp.\n Use with a time value initialized to 0 to obtain the number of seconds since\n the epoch. The operation will write the current timestamp in start.\n\n Usage:\n @code\n ecs_time_t t = {};\n ecs_time_measure(&t);\n // code\n double elapsed = ecs_time_measure(&t);\n @endcode\n\n @param start The starting timestamp.\n @return The time elapsed since start."]
    pub fn ecs_time_measure(start: *mut ecs_time_t) -> f64;
}
extern "C" {
    #[doc = " Calculate difference between two timestamps.\n\n @param t1 The first timestamp.\n @param t2 The first timestamp.\n @return The difference between timestamps."]
    pub fn ecs_time_sub(t1: ecs_time_t, t2: ecs_time_t) -> ecs_time_t;
}
extern "C" {
    #[doc = " Convert time value to a double.\n\n @param t The timestamp.\n @return The timestamp converted to a double."]
    pub fn ecs_time_to_double(t: ecs_time_t) -> f64;
}
extern "C" {
    #[doc = " Return newly allocated memory that contains a copy of src.\n\n @param src The source pointer.\n @param size The number of bytes to copy.\n @return The duplicated memory."]
    pub fn ecs_os_memdup(
        src: *const ::std::os::raw::c_void,
        size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Are heap functions available?"]
    pub fn ecs_os_has_heap() -> bool;
}
extern "C" {
    #[doc = " Are threading functions available?"]
    pub fn ecs_os_has_threading() -> bool;
}
extern "C" {
    #[doc = " Are task functions available?"]
    pub fn ecs_os_has_task_support() -> bool;
}
extern "C" {
    #[doc = " Are time functions available?"]
    pub fn ecs_os_has_time() -> bool;
}
extern "C" {
    #[doc = " Are logging functions available?"]
    pub fn ecs_os_has_logging() -> bool;
}
extern "C" {
    #[doc = " Are dynamic library functions available?"]
    pub fn ecs_os_has_dl() -> bool;
}
extern "C" {
    #[doc = " Are module path functions available?"]
    pub fn ecs_os_has_modules() -> bool;
}
#[doc = " Ids are the things that can be added to an entity.\n An id can be an entity or pair, and can have optional id flags."]
pub type ecs_id_t = u64;
#[doc = " An entity identifier.\n Entity ids consist out of a number unique to the entity in the lower 32 bits,\n and a counter used to track entity liveliness in the upper 32 bits. When an\n id is recycled, its generation count is increased. This causes recycled ids\n to be very large (>4 billion), which is normal."]
pub type ecs_entity_t = ecs_id_t;
#[doc = " A type is a list of (component) ids.\n Types are used to communicate the \"type\" of an entity. In most type systems a\n typeof operation returns a single type. In ECS however, an entity can have\n multiple components, which is why an ECS type consists of a vector of ids.\n\n The component ids of a type are sorted, which ensures that it doesn't matter\n in which order components are added to an entity. For example, if adding\n Position then Velocity would result in type [Position, Velocity], first\n adding Velocity then Position would also result in type [Position, Velocity].\n\n Entities are grouped together by type in the ECS storage in tables. The\n storage has exactly one table per unique type that is created by the\n application that stores all entities and components for that type. This is\n also referred to as an archetype."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_type_t {
    #[doc = "< Array with ids."]
    pub array: *mut ecs_id_t,
    #[doc = "< Number of elements in array."]
    pub count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_type_t"][::std::mem::size_of::<ecs_type_t>() - 16usize];
    ["Alignment of ecs_type_t"][::std::mem::align_of::<ecs_type_t>() - 8usize];
    ["Offset of field: ecs_type_t::array"][::std::mem::offset_of!(ecs_type_t, array) - 0usize];
    ["Offset of field: ecs_type_t::count"][::std::mem::offset_of!(ecs_type_t, count) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_stage_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_id_record_t {
    _unused: [u8; 0],
}
#[doc = " A poly object.\n A poly (short for polymorph) object is an object that has a variable list of\n capabilities, determined by a mixin table. This is the current list of types\n in the flecs API that can be used as an ecs_poly_t:\n\n - ecs_world_t\n - ecs_stage_t\n - ecs_query_t\n\n Functions that accept an ecs_poly_t argument can accept objects of these\n types. If the object does not have the requested mixin the API will throw an\n assert.\n\n The poly/mixin framework enables partially overlapping features to be\n implemented once, and enables objects of different types to interact with\n each other depending on what mixins they have, rather than their type\n (in some ways it's like a mini-ECS). Additionally, each poly object has a\n header that enables the API to do sanity checking on the input arguments."]
pub type ecs_poly_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_mixins_t {
    _unused: [u8; 0],
}
#[doc = " Header for ecs_poly_t objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_header_t {
    #[doc = "< Magic number verifying it's a flecs object"]
    pub magic: i32,
    #[doc = "< Magic number indicating which type of flecs object"]
    pub type_: i32,
    #[doc = "< Refcount, to enable RAII handles"]
    pub refcount: i32,
    #[doc = "< Table with offsets to (optional) mixins"]
    pub mixins: *mut ecs_mixins_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_header_t"][::std::mem::size_of::<ecs_header_t>() - 24usize];
    ["Alignment of ecs_header_t"][::std::mem::align_of::<ecs_header_t>() - 8usize];
    ["Offset of field: ecs_header_t::magic"][::std::mem::offset_of!(ecs_header_t, magic) - 0usize];
    ["Offset of field: ecs_header_t::type_"][::std::mem::offset_of!(ecs_header_t, type_) - 4usize];
    ["Offset of field: ecs_header_t::refcount"]
        [::std::mem::offset_of!(ecs_header_t, refcount) - 8usize];
    ["Offset of field: ecs_header_t::mixins"]
        [::std::mem::offset_of!(ecs_header_t, mixins) - 16usize];
};
#[doc = " Record for entity index"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_record_t {
    #[doc = "< Id record to (*, entity) for target entities"]
    pub idr: *mut ecs_id_record_t,
    #[doc = "< Identifies a type (and table) in world"]
    pub table: *mut ecs_table_t,
    #[doc = "< Table row of the entity"]
    pub row: u32,
    #[doc = "< Index in dense array of entity index"]
    pub dense: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_record_t"][::std::mem::size_of::<ecs_record_t>() - 24usize];
    ["Alignment of ecs_record_t"][::std::mem::align_of::<ecs_record_t>() - 8usize];
    ["Offset of field: ecs_record_t::idr"][::std::mem::offset_of!(ecs_record_t, idr) - 0usize];
    ["Offset of field: ecs_record_t::table"][::std::mem::offset_of!(ecs_record_t, table) - 8usize];
    ["Offset of field: ecs_record_t::row"][::std::mem::offset_of!(ecs_record_t, row) - 16usize];
    ["Offset of field: ecs_record_t::dense"][::std::mem::offset_of!(ecs_record_t, dense) - 20usize];
};
#[doc = " Header for table cache elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_cache_hdr_t {
    #[doc = "< Table cache of element. Of type ecs_id_record_t* for component index elements."]
    pub cache: *mut ecs_table_cache_t,
    #[doc = "< Table associated with element."]
    pub table: *mut ecs_table_t,
    #[doc = "< Next/previous elements for id in table cache."]
    pub prev: *mut ecs_table_cache_hdr_t,
    #[doc = "< Next/previous elements for id in table cache."]
    pub next: *mut ecs_table_cache_hdr_t,
    #[doc = "< Whether element is in empty list."]
    pub empty: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_table_cache_hdr_t"][::std::mem::size_of::<ecs_table_cache_hdr_t>() - 40usize];
    ["Alignment of ecs_table_cache_hdr_t"]
        [::std::mem::align_of::<ecs_table_cache_hdr_t>() - 8usize];
    ["Offset of field: ecs_table_cache_hdr_t::cache"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, cache) - 0usize];
    ["Offset of field: ecs_table_cache_hdr_t::table"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, table) - 8usize];
    ["Offset of field: ecs_table_cache_hdr_t::prev"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, prev) - 16usize];
    ["Offset of field: ecs_table_cache_hdr_t::next"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, next) - 24usize];
    ["Offset of field: ecs_table_cache_hdr_t::empty"]
        [::std::mem::offset_of!(ecs_table_cache_hdr_t, empty) - 32usize];
};
#[doc = " Metadata describing where a component id is stored in a table.\n This type is used as element type for the component index table cache. One\n record exists per table/component in the table. Only records for wildcard ids\n can have a count > 1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_record_t {
    #[doc = "< Table cache header"]
    pub hdr: ecs_table_cache_hdr_t,
    #[doc = "< First type index where id occurs in table"]
    pub index: i16,
    #[doc = "< Number of times id occurs in table"]
    pub count: i16,
    #[doc = "< First column index where id occurs"]
    pub column: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_table_record_t"][::std::mem::size_of::<ecs_table_record_t>() - 48usize];
    ["Alignment of ecs_table_record_t"][::std::mem::align_of::<ecs_table_record_t>() - 8usize];
    ["Offset of field: ecs_table_record_t::hdr"]
        [::std::mem::offset_of!(ecs_table_record_t, hdr) - 0usize];
    ["Offset of field: ecs_table_record_t::index"]
        [::std::mem::offset_of!(ecs_table_record_t, index) - 40usize];
    ["Offset of field: ecs_table_record_t::count"]
        [::std::mem::offset_of!(ecs_table_record_t, count) - 42usize];
    ["Offset of field: ecs_table_record_t::column"]
        [::std::mem::offset_of!(ecs_table_record_t, column) - 44usize];
};
#[doc = " Function prototype for runnables (systems, observers).\n The run callback overrides the default behavior for iterating through the\n results of a runnable object.\n\n The default runnable iterates the iterator, and calls an iter_action (see\n below) for each returned result.\n\n @param it The iterator to be iterated by the runnable."]
pub type ecs_run_action_t = ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t)>;
#[doc = " Function prototype for iterables.\n A system may invoke a callback multiple times, typically once for each\n matched table.\n\n @param it The iterator containing the data for the current match."]
pub type ecs_iter_action_t = ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t)>;
#[doc = " Function prototype for iterating an iterator.\n Stored inside initialized iterators. This allows an application to iterate\n an iterator without needing to know what created it.\n\n @param it The iterator to iterate.\n @return True if iterator has no more results, false if it does."]
pub type ecs_iter_next_action_t =
    ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t) -> bool>;
#[doc = " Function prototype for freeing an iterator.\n Free iterator resources.\n\n @param it The iterator to free."]
pub type ecs_iter_fini_action_t = ::std::option::Option<unsafe extern "C" fn(it: *mut ecs_iter_t)>;
#[doc = " Callback used for comparing components"]
pub type ecs_order_by_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        e1: ecs_entity_t,
        ptr1: *const ::std::os::raw::c_void,
        e2: ecs_entity_t,
        ptr2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback used for sorting the entire table of components"]
pub type ecs_sort_table_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        entities: *mut ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
        size: i32,
        lo: i32,
        hi: i32,
        order_by: ecs_order_by_action_t,
    ),
>;
#[doc = " Callback used for grouping tables in a query"]
pub type ecs_group_by_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        group_id: ecs_id_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> u64,
>;
#[doc = " Callback invoked when a query creates a new group."]
pub type ecs_group_create_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        group_id: u64,
        group_by_ctx: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Callback invoked when a query deletes an existing group."]
pub type ecs_group_delete_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        world: *mut ecs_world_t,
        group_id: u64,
        group_ctx: *mut ::std::os::raw::c_void,
        group_by_ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Initialization action for modules"]
pub type ecs_module_action_t = ::std::option::Option<unsafe extern "C" fn(world: *mut ecs_world_t)>;
#[doc = " Action callback on world exit"]
pub type ecs_fini_action_t = ::std::option::Option<
    unsafe extern "C" fn(world: *mut ecs_world_t, ctx: *mut ::std::os::raw::c_void),
>;
#[doc = " Function to cleanup context data"]
pub type ecs_ctx_free_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
#[doc = " Callback used for sorting values"]
pub type ecs_compare_action_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr1: *const ::std::os::raw::c_void,
        ptr2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Callback used for hashing values"]
pub type ecs_hash_value_action_t =
    ::std::option::Option<unsafe extern "C" fn(ptr: *const ::std::os::raw::c_void) -> u64>;
#[doc = " Constructor/destructor callback"]
pub type ecs_xtor_t = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        count: i32,
        type_info: *const ecs_type_info_t,
    ),
>;
#[doc = " Copy is invoked when a component is copied into another component."]
pub type ecs_copy_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst_ptr: *mut ::std::os::raw::c_void,
        src_ptr: *const ::std::os::raw::c_void,
        count: i32,
        type_info: *const ecs_type_info_t,
    ),
>;
#[doc = " Move is invoked when a component is moved to another component."]
pub type ecs_move_t = ::std::option::Option<
    unsafe extern "C" fn(
        dst_ptr: *mut ::std::os::raw::c_void,
        src_ptr: *mut ::std::os::raw::c_void,
        count: i32,
        type_info: *const ecs_type_info_t,
    ),
>;
#[doc = " Destructor function for poly objects."]
pub type flecs_poly_dtor_t = ::std::option::Option<unsafe extern "C" fn(poly: *mut ecs_poly_t)>;
#[doc = "< InOut for regular terms, In for shared terms"]
pub const ecs_inout_kind_t_EcsInOutDefault: ecs_inout_kind_t = 0;
#[doc = "< Term is neither read nor written"]
pub const ecs_inout_kind_t_EcsInOutNone: ecs_inout_kind_t = 1;
#[doc = "< Same as InOutNone + prevents term from triggering observers"]
pub const ecs_inout_kind_t_EcsInOutFilter: ecs_inout_kind_t = 2;
#[doc = "< Term is both read and written"]
pub const ecs_inout_kind_t_EcsInOut: ecs_inout_kind_t = 3;
#[doc = "< Term is only read"]
pub const ecs_inout_kind_t_EcsIn: ecs_inout_kind_t = 4;
#[doc = "< Term is only written"]
pub const ecs_inout_kind_t_EcsOut: ecs_inout_kind_t = 5;
#[doc = " Specify read/write access for term"]
pub type ecs_inout_kind_t = ::std::os::raw::c_int;
#[doc = "< The term must match"]
pub const ecs_oper_kind_t_EcsAnd: ecs_oper_kind_t = 0;
#[doc = "< One of the terms in an or chain must match"]
pub const ecs_oper_kind_t_EcsOr: ecs_oper_kind_t = 1;
#[doc = "< The term must not match"]
pub const ecs_oper_kind_t_EcsNot: ecs_oper_kind_t = 2;
#[doc = "< The term may match"]
pub const ecs_oper_kind_t_EcsOptional: ecs_oper_kind_t = 3;
#[doc = "< Term must match all components from term id"]
pub const ecs_oper_kind_t_EcsAndFrom: ecs_oper_kind_t = 4;
#[doc = "< Term must match at least one component from term id"]
pub const ecs_oper_kind_t_EcsOrFrom: ecs_oper_kind_t = 5;
#[doc = "< Term must match none of the components from term id"]
pub const ecs_oper_kind_t_EcsNotFrom: ecs_oper_kind_t = 6;
#[doc = " Specify operator for term"]
pub type ecs_oper_kind_t = ::std::os::raw::c_int;
#[doc = "< Behavior determined by query creation context"]
pub const ecs_query_cache_kind_t_EcsQueryCacheDefault: ecs_query_cache_kind_t = 0;
#[doc = "< Cache query terms that are cacheable"]
pub const ecs_query_cache_kind_t_EcsQueryCacheAuto: ecs_query_cache_kind_t = 1;
#[doc = "< Require that all query terms can be cached"]
pub const ecs_query_cache_kind_t_EcsQueryCacheAll: ecs_query_cache_kind_t = 2;
#[doc = "< No caching"]
pub const ecs_query_cache_kind_t_EcsQueryCacheNone: ecs_query_cache_kind_t = 3;
#[doc = " Specify cache policy for query"]
pub type ecs_query_cache_kind_t = ::std::os::raw::c_int;
#[doc = " Type that describes a reference to an entity or variable in a term."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_term_ref_t {
    #[doc = "< Entity id. If left to 0 and flags does not\n specify whether id is an entity or a variable\n the id will be initialized to #EcsThis.\n To explicitly set the id to 0, leave the id\n member to 0 and set #EcsIsEntity in flags."]
    pub id: ecs_entity_t,
    #[doc = "< Name. This can be either the variable name\n (when the #EcsIsVariable flag is set) or an\n entity name. When ecs_term_t::move is true,\n the API assumes ownership over the string and\n will free it when the term is destroyed."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_term_ref_t"][::std::mem::size_of::<ecs_term_ref_t>() - 16usize];
    ["Alignment of ecs_term_ref_t"][::std::mem::align_of::<ecs_term_ref_t>() - 8usize];
    ["Offset of field: ecs_term_ref_t::id"][::std::mem::offset_of!(ecs_term_ref_t, id) - 0usize];
    ["Offset of field: ecs_term_ref_t::name"]
        [::std::mem::offset_of!(ecs_term_ref_t, name) - 8usize];
};
#[doc = " Type that describes a term (single element in a query)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_term_t {
    #[doc = "< Component id to be matched by term. Can be\n set directly, or will be populated from the\n first/second members, which provide more\n flexibility."]
    pub id: ecs_id_t,
    #[doc = "< Source of term"]
    pub src: ecs_term_ref_t,
    #[doc = "< Component or first element of pair"]
    pub first: ecs_term_ref_t,
    #[doc = "< Second element of pair"]
    pub second: ecs_term_ref_t,
    #[doc = "< Relationship to traverse when looking for the\n component. The relationship must have\n the `Traversable` property. Default is `IsA`."]
    pub trav: ecs_entity_t,
    #[doc = "< Access to contents matched by term"]
    pub inout: i16,
    #[doc = "< Operator of term"]
    pub oper: i16,
    #[doc = "< Index of field for term in iterator"]
    pub field_index: i8,
    #[doc = "< Flags that help eval, set by ecs_query_init()"]
    pub flags_: ecs_flags16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_term_t"][::std::mem::size_of::<ecs_term_t>() - 72usize];
    ["Alignment of ecs_term_t"][::std::mem::align_of::<ecs_term_t>() - 8usize];
    ["Offset of field: ecs_term_t::id"][::std::mem::offset_of!(ecs_term_t, id) - 0usize];
    ["Offset of field: ecs_term_t::src"][::std::mem::offset_of!(ecs_term_t, src) - 8usize];
    ["Offset of field: ecs_term_t::first"][::std::mem::offset_of!(ecs_term_t, first) - 24usize];
    ["Offset of field: ecs_term_t::second"][::std::mem::offset_of!(ecs_term_t, second) - 40usize];
    ["Offset of field: ecs_term_t::trav"][::std::mem::offset_of!(ecs_term_t, trav) - 56usize];
    ["Offset of field: ecs_term_t::inout"][::std::mem::offset_of!(ecs_term_t, inout) - 64usize];
    ["Offset of field: ecs_term_t::oper"][::std::mem::offset_of!(ecs_term_t, oper) - 66usize];
    ["Offset of field: ecs_term_t::field_index"]
        [::std::mem::offset_of!(ecs_term_t, field_index) - 68usize];
    ["Offset of field: ecs_term_t::flags_"][::std::mem::offset_of!(ecs_term_t, flags_) - 70usize];
};
#[doc = " Queries are lists of constraints (terms) that match entities.\n Created with ecs_query_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_t {
    #[doc = "< Object header"]
    pub hdr: ecs_header_t,
    #[doc = "< Query terms"]
    pub terms: [ecs_term_t; 32usize],
    #[doc = "< Component sizes. Indexed by field"]
    pub sizes: [i32; 32usize],
    #[doc = "< Component ids. Indexed by field"]
    pub ids: [ecs_id_t; 32usize],
    #[doc = "< Query flags"]
    pub flags: ecs_flags32_t,
    #[doc = "< Number of query variables"]
    pub var_count: i8,
    #[doc = "< Number of query terms"]
    pub term_count: i8,
    #[doc = "< Number of fields returned by query"]
    pub field_count: i8,
    #[doc = "< Fields with a fixed source"]
    pub fixed_fields: ecs_flags32_t,
    #[doc = "< Fields with a static (component) id"]
    pub static_id_fields: ecs_flags32_t,
    #[doc = "< Fields that have data"]
    pub data_fields: ecs_flags32_t,
    #[doc = "< Fields that write data"]
    pub write_fields: ecs_flags32_t,
    #[doc = "< Fields that read data"]
    pub read_fields: ecs_flags32_t,
    #[doc = "< Fields that must be acquired with field_at"]
    pub row_fields: ecs_flags32_t,
    #[doc = "< Fields that don't write shared data"]
    pub shared_readonly_fields: ecs_flags32_t,
    #[doc = "< Fields that will be set"]
    pub set_fields: ecs_flags32_t,
    #[doc = "< Caching policy of query"]
    pub cache_kind: ecs_query_cache_kind_t,
    #[doc = "< Array with variable names for iterator"]
    pub vars: *mut *mut ::std::os::raw::c_char,
    #[doc = "< User context to pass to callback"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Context to be used for language bindings"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Entity associated with query (optional)"]
    pub entity: ecs_entity_t,
    #[doc = "< Actual world."]
    pub real_world: *mut ecs_world_t,
    #[doc = "< World or stage query was created with."]
    pub world: *mut ecs_world_t,
    #[doc = "< Number of times query is evaluated"]
    pub eval_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_t"][::std::mem::size_of::<ecs_query_t>() - 2816usize];
    ["Alignment of ecs_query_t"][::std::mem::align_of::<ecs_query_t>() - 8usize];
    ["Offset of field: ecs_query_t::hdr"][::std::mem::offset_of!(ecs_query_t, hdr) - 0usize];
    ["Offset of field: ecs_query_t::terms"][::std::mem::offset_of!(ecs_query_t, terms) - 24usize];
    ["Offset of field: ecs_query_t::sizes"][::std::mem::offset_of!(ecs_query_t, sizes) - 2328usize];
    ["Offset of field: ecs_query_t::ids"][::std::mem::offset_of!(ecs_query_t, ids) - 2456usize];
    ["Offset of field: ecs_query_t::flags"][::std::mem::offset_of!(ecs_query_t, flags) - 2712usize];
    ["Offset of field: ecs_query_t::var_count"]
        [::std::mem::offset_of!(ecs_query_t, var_count) - 2716usize];
    ["Offset of field: ecs_query_t::term_count"]
        [::std::mem::offset_of!(ecs_query_t, term_count) - 2717usize];
    ["Offset of field: ecs_query_t::field_count"]
        [::std::mem::offset_of!(ecs_query_t, field_count) - 2718usize];
    ["Offset of field: ecs_query_t::fixed_fields"]
        [::std::mem::offset_of!(ecs_query_t, fixed_fields) - 2720usize];
    ["Offset of field: ecs_query_t::static_id_fields"]
        [::std::mem::offset_of!(ecs_query_t, static_id_fields) - 2724usize];
    ["Offset of field: ecs_query_t::data_fields"]
        [::std::mem::offset_of!(ecs_query_t, data_fields) - 2728usize];
    ["Offset of field: ecs_query_t::write_fields"]
        [::std::mem::offset_of!(ecs_query_t, write_fields) - 2732usize];
    ["Offset of field: ecs_query_t::read_fields"]
        [::std::mem::offset_of!(ecs_query_t, read_fields) - 2736usize];
    ["Offset of field: ecs_query_t::row_fields"]
        [::std::mem::offset_of!(ecs_query_t, row_fields) - 2740usize];
    ["Offset of field: ecs_query_t::shared_readonly_fields"]
        [::std::mem::offset_of!(ecs_query_t, shared_readonly_fields) - 2744usize];
    ["Offset of field: ecs_query_t::set_fields"]
        [::std::mem::offset_of!(ecs_query_t, set_fields) - 2748usize];
    ["Offset of field: ecs_query_t::cache_kind"]
        [::std::mem::offset_of!(ecs_query_t, cache_kind) - 2752usize];
    ["Offset of field: ecs_query_t::vars"][::std::mem::offset_of!(ecs_query_t, vars) - 2760usize];
    ["Offset of field: ecs_query_t::ctx"][::std::mem::offset_of!(ecs_query_t, ctx) - 2768usize];
    ["Offset of field: ecs_query_t::binding_ctx"]
        [::std::mem::offset_of!(ecs_query_t, binding_ctx) - 2776usize];
    ["Offset of field: ecs_query_t::entity"]
        [::std::mem::offset_of!(ecs_query_t, entity) - 2784usize];
    ["Offset of field: ecs_query_t::real_world"]
        [::std::mem::offset_of!(ecs_query_t, real_world) - 2792usize];
    ["Offset of field: ecs_query_t::world"][::std::mem::offset_of!(ecs_query_t, world) - 2800usize];
    ["Offset of field: ecs_query_t::eval_count"]
        [::std::mem::offset_of!(ecs_query_t, eval_count) - 2808usize];
};
#[doc = " An observer reacts to events matching a query.\n Created with ecs_observer_init()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_observer_t {
    #[doc = "< Object header"]
    pub hdr: ecs_header_t,
    #[doc = "< Observer query"]
    pub query: *mut ecs_query_t,
    #[doc = " Observer events"]
    pub events: [ecs_entity_t; 8usize],
    #[doc = "< Number of events"]
    pub event_count: i32,
    #[doc = "< See ecs_observer_desc_t::callback"]
    pub callback: ecs_iter_action_t,
    #[doc = "< See ecs_observer_desc_t::run"]
    pub run: ecs_run_action_t,
    #[doc = "< Observer context"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback language binding context"]
    pub callback_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Run language binding context"]
    pub run_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = "< Callback to free callback_ctx"]
    pub callback_ctx_free: ecs_ctx_free_t,
    #[doc = "< Callback to free run_ctx"]
    pub run_ctx_free: ecs_ctx_free_t,
    #[doc = "< Observable for observer"]
    pub observable: *mut ecs_observable_t,
    #[doc = "< The world"]
    pub world: *mut ecs_world_t,
    #[doc = "< Entity associated with observer"]
    pub entity: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_observer_t"][::std::mem::size_of::<ecs_observer_t>() - 192usize];
    ["Alignment of ecs_observer_t"][::std::mem::align_of::<ecs_observer_t>() - 8usize];
    ["Offset of field: ecs_observer_t::hdr"][::std::mem::offset_of!(ecs_observer_t, hdr) - 0usize];
    ["Offset of field: ecs_observer_t::query"]
        [::std::mem::offset_of!(ecs_observer_t, query) - 24usize];
    ["Offset of field: ecs_observer_t::events"]
        [::std::mem::offset_of!(ecs_observer_t, events) - 32usize];
    ["Offset of field: ecs_observer_t::event_count"]
        [::std::mem::offset_of!(ecs_observer_t, event_count) - 96usize];
    ["Offset of field: ecs_observer_t::callback"]
        [::std::mem::offset_of!(ecs_observer_t, callback) - 104usize];
    ["Offset of field: ecs_observer_t::run"]
        [::std::mem::offset_of!(ecs_observer_t, run) - 112usize];
    ["Offset of field: ecs_observer_t::ctx"]
        [::std::mem::offset_of!(ecs_observer_t, ctx) - 120usize];
    ["Offset of field: ecs_observer_t::callback_ctx"]
        [::std::mem::offset_of!(ecs_observer_t, callback_ctx) - 128usize];
    ["Offset of field: ecs_observer_t::run_ctx"]
        [::std::mem::offset_of!(ecs_observer_t, run_ctx) - 136usize];
    ["Offset of field: ecs_observer_t::ctx_free"]
        [::std::mem::offset_of!(ecs_observer_t, ctx_free) - 144usize];
    ["Offset of field: ecs_observer_t::callback_ctx_free"]
        [::std::mem::offset_of!(ecs_observer_t, callback_ctx_free) - 152usize];
    ["Offset of field: ecs_observer_t::run_ctx_free"]
        [::std::mem::offset_of!(ecs_observer_t, run_ctx_free) - 160usize];
    ["Offset of field: ecs_observer_t::observable"]
        [::std::mem::offset_of!(ecs_observer_t, observable) - 168usize];
    ["Offset of field: ecs_observer_t::world"]
        [::std::mem::offset_of!(ecs_observer_t, world) - 176usize];
    ["Offset of field: ecs_observer_t::entity"]
        [::std::mem::offset_of!(ecs_observer_t, entity) - 184usize];
};
#[doc = " Type that contains component lifecycle callbacks.\n\n @ingroup components"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_type_hooks_t {
    #[doc = "< ctor"]
    pub ctor: ecs_xtor_t,
    #[doc = "< dtor"]
    pub dtor: ecs_xtor_t,
    #[doc = "< copy assignment"]
    pub copy: ecs_copy_t,
    #[doc = "< move assignment"]
    pub move_: ecs_move_t,
    #[doc = " Ctor + copy"]
    pub copy_ctor: ecs_copy_t,
    #[doc = " Ctor + move"]
    pub move_ctor: ecs_move_t,
    #[doc = " Ctor + move + dtor (or move_ctor + dtor).\n This combination is typically used when a component is moved from one\n location to a new location, like when it is moved to a new table. If\n not set explicitly it will be derived from other callbacks."]
    pub ctor_move_dtor: ecs_move_t,
    #[doc = " Move + dtor.\n This combination is typically used when a component is moved from one\n location to an existing location, like what happens during a remove. If\n not set explicitly it will be derived from other callbacks."]
    pub move_dtor: ecs_move_t,
    #[doc = " Callback that is invoked when an instance of a component is added. This\n callback is invoked before triggers are invoked."]
    pub on_add: ecs_iter_action_t,
    #[doc = " Callback that is invoked when an instance of the component is set. This\n callback is invoked before triggers are invoked, and enable the component\n to respond to changes on itself before others can."]
    pub on_set: ecs_iter_action_t,
    #[doc = " Callback that is invoked when an instance of the component is removed.\n This callback is invoked after the triggers are invoked, and before the\n destructor is invoked."]
    pub on_remove: ecs_iter_action_t,
    #[doc = "< User defined context"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Language binding context"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = "< Callback to free binding_ctx"]
    pub binding_ctx_free: ecs_ctx_free_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_type_hooks_t"][::std::mem::size_of::<ecs_type_hooks_t>() - 120usize];
    ["Alignment of ecs_type_hooks_t"][::std::mem::align_of::<ecs_type_hooks_t>() - 8usize];
    ["Offset of field: ecs_type_hooks_t::ctor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, ctor) - 0usize];
    ["Offset of field: ecs_type_hooks_t::dtor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, dtor) - 8usize];
    ["Offset of field: ecs_type_hooks_t::copy"]
        [::std::mem::offset_of!(ecs_type_hooks_t, copy) - 16usize];
    ["Offset of field: ecs_type_hooks_t::move_"]
        [::std::mem::offset_of!(ecs_type_hooks_t, move_) - 24usize];
    ["Offset of field: ecs_type_hooks_t::copy_ctor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, copy_ctor) - 32usize];
    ["Offset of field: ecs_type_hooks_t::move_ctor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, move_ctor) - 40usize];
    ["Offset of field: ecs_type_hooks_t::ctor_move_dtor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, ctor_move_dtor) - 48usize];
    ["Offset of field: ecs_type_hooks_t::move_dtor"]
        [::std::mem::offset_of!(ecs_type_hooks_t, move_dtor) - 56usize];
    ["Offset of field: ecs_type_hooks_t::on_add"]
        [::std::mem::offset_of!(ecs_type_hooks_t, on_add) - 64usize];
    ["Offset of field: ecs_type_hooks_t::on_set"]
        [::std::mem::offset_of!(ecs_type_hooks_t, on_set) - 72usize];
    ["Offset of field: ecs_type_hooks_t::on_remove"]
        [::std::mem::offset_of!(ecs_type_hooks_t, on_remove) - 80usize];
    ["Offset of field: ecs_type_hooks_t::ctx"]
        [::std::mem::offset_of!(ecs_type_hooks_t, ctx) - 88usize];
    ["Offset of field: ecs_type_hooks_t::binding_ctx"]
        [::std::mem::offset_of!(ecs_type_hooks_t, binding_ctx) - 96usize];
    ["Offset of field: ecs_type_hooks_t::ctx_free"]
        [::std::mem::offset_of!(ecs_type_hooks_t, ctx_free) - 104usize];
    ["Offset of field: ecs_type_hooks_t::binding_ctx_free"]
        [::std::mem::offset_of!(ecs_type_hooks_t, binding_ctx_free) - 112usize];
};
#[doc = " Type that contains component information (passed to ctors/dtors/...)\n\n @ingroup components"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_type_info_t {
    #[doc = "< Size of type"]
    pub size: ecs_size_t,
    #[doc = "< Alignment of type"]
    pub alignment: ecs_size_t,
    #[doc = "< Type hooks"]
    pub hooks: ecs_type_hooks_t,
    #[doc = "< Handle to component (do not set)"]
    pub component: ecs_entity_t,
    #[doc = "< Type name."]
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_type_info_t"][::std::mem::size_of::<ecs_type_info_t>() - 144usize];
    ["Alignment of ecs_type_info_t"][::std::mem::align_of::<ecs_type_info_t>() - 8usize];
    ["Offset of field: ecs_type_info_t::size"]
        [::std::mem::offset_of!(ecs_type_info_t, size) - 0usize];
    ["Offset of field: ecs_type_info_t::alignment"]
        [::std::mem::offset_of!(ecs_type_info_t, alignment) - 4usize];
    ["Offset of field: ecs_type_info_t::hooks"]
        [::std::mem::offset_of!(ecs_type_info_t, hooks) - 8usize];
    ["Offset of field: ecs_type_info_t::component"]
        [::std::mem::offset_of!(ecs_type_info_t, component) - 128usize];
    ["Offset of field: ecs_type_info_t::name"]
        [::std::mem::offset_of!(ecs_type_info_t, name) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_data_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_cache_table_match_t {
    _unused: [u8; 0],
}
#[doc = " All observers for a specific event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_event_record_t {
    pub any: *mut ecs_event_id_record_t,
    pub wildcard: *mut ecs_event_id_record_t,
    pub wildcard_pair: *mut ecs_event_id_record_t,
    pub event_ids: ecs_map_t,
    pub event: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_event_record_t"][::std::mem::size_of::<ecs_event_record_t>() - 72usize];
    ["Alignment of ecs_event_record_t"][::std::mem::align_of::<ecs_event_record_t>() - 8usize];
    ["Offset of field: ecs_event_record_t::any"]
        [::std::mem::offset_of!(ecs_event_record_t, any) - 0usize];
    ["Offset of field: ecs_event_record_t::wildcard"]
        [::std::mem::offset_of!(ecs_event_record_t, wildcard) - 8usize];
    ["Offset of field: ecs_event_record_t::wildcard_pair"]
        [::std::mem::offset_of!(ecs_event_record_t, wildcard_pair) - 16usize];
    ["Offset of field: ecs_event_record_t::event_ids"]
        [::std::mem::offset_of!(ecs_event_record_t, event_ids) - 24usize];
    ["Offset of field: ecs_event_record_t::event"]
        [::std::mem::offset_of!(ecs_event_record_t, event) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_observable_t {
    pub on_add: ecs_event_record_t,
    pub on_remove: ecs_event_record_t,
    pub on_set: ecs_event_record_t,
    pub on_wildcard: ecs_event_record_t,
    pub events: ecs_sparse_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_observable_t"][::std::mem::size_of::<ecs_observable_t>() - 352usize];
    ["Alignment of ecs_observable_t"][::std::mem::align_of::<ecs_observable_t>() - 8usize];
    ["Offset of field: ecs_observable_t::on_add"]
        [::std::mem::offset_of!(ecs_observable_t, on_add) - 0usize];
    ["Offset of field: ecs_observable_t::on_remove"]
        [::std::mem::offset_of!(ecs_observable_t, on_remove) - 72usize];
    ["Offset of field: ecs_observable_t::on_set"]
        [::std::mem::offset_of!(ecs_observable_t, on_set) - 144usize];
    ["Offset of field: ecs_observable_t::on_wildcard"]
        [::std::mem::offset_of!(ecs_observable_t, on_wildcard) - 216usize];
    ["Offset of field: ecs_observable_t::events"]
        [::std::mem::offset_of!(ecs_observable_t, events) - 288usize];
};
#[doc = " Range in table"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_range_t {
    pub table: *mut ecs_table_t,
    pub offset: i32,
    pub count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_table_range_t"][::std::mem::size_of::<ecs_table_range_t>() - 16usize];
    ["Alignment of ecs_table_range_t"][::std::mem::align_of::<ecs_table_range_t>() - 8usize];
    ["Offset of field: ecs_table_range_t::table"]
        [::std::mem::offset_of!(ecs_table_range_t, table) - 0usize];
    ["Offset of field: ecs_table_range_t::offset"]
        [::std::mem::offset_of!(ecs_table_range_t, offset) - 8usize];
    ["Offset of field: ecs_table_range_t::count"]
        [::std::mem::offset_of!(ecs_table_range_t, count) - 12usize];
};
#[doc = " Value of query variable"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_var_t {
    pub range: ecs_table_range_t,
    pub entity: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_var_t"][::std::mem::size_of::<ecs_var_t>() - 24usize];
    ["Alignment of ecs_var_t"][::std::mem::align_of::<ecs_var_t>() - 8usize];
    ["Offset of field: ecs_var_t::range"][::std::mem::offset_of!(ecs_var_t, range) - 0usize];
    ["Offset of field: ecs_var_t::entity"][::std::mem::offset_of!(ecs_var_t, entity) - 16usize];
};
#[doc = " Cached reference."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_ref_t {
    pub entity: ecs_entity_t,
    pub id: ecs_entity_t,
    pub table_id: u64,
    pub tr: *mut ecs_table_record_t,
    pub record: *mut ecs_record_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_ref_t"][::std::mem::size_of::<ecs_ref_t>() - 40usize];
    ["Alignment of ecs_ref_t"][::std::mem::align_of::<ecs_ref_t>() - 8usize];
    ["Offset of field: ecs_ref_t::entity"][::std::mem::offset_of!(ecs_ref_t, entity) - 0usize];
    ["Offset of field: ecs_ref_t::id"][::std::mem::offset_of!(ecs_ref_t, id) - 8usize];
    ["Offset of field: ecs_ref_t::table_id"][::std::mem::offset_of!(ecs_ref_t, table_id) - 16usize];
    ["Offset of field: ecs_ref_t::tr"][::std::mem::offset_of!(ecs_ref_t, tr) - 24usize];
    ["Offset of field: ecs_ref_t::record"][::std::mem::offset_of!(ecs_ref_t, record) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_page_iter_t {
    pub offset: i32,
    pub limit: i32,
    pub remaining: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_page_iter_t"][::std::mem::size_of::<ecs_page_iter_t>() - 12usize];
    ["Alignment of ecs_page_iter_t"][::std::mem::align_of::<ecs_page_iter_t>() - 4usize];
    ["Offset of field: ecs_page_iter_t::offset"]
        [::std::mem::offset_of!(ecs_page_iter_t, offset) - 0usize];
    ["Offset of field: ecs_page_iter_t::limit"]
        [::std::mem::offset_of!(ecs_page_iter_t, limit) - 4usize];
    ["Offset of field: ecs_page_iter_t::remaining"]
        [::std::mem::offset_of!(ecs_page_iter_t, remaining) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_worker_iter_t {
    pub index: i32,
    pub count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_worker_iter_t"][::std::mem::size_of::<ecs_worker_iter_t>() - 8usize];
    ["Alignment of ecs_worker_iter_t"][::std::mem::align_of::<ecs_worker_iter_t>() - 4usize];
    ["Offset of field: ecs_worker_iter_t::index"]
        [::std::mem::offset_of!(ecs_worker_iter_t, index) - 0usize];
    ["Offset of field: ecs_worker_iter_t::count"]
        [::std::mem::offset_of!(ecs_worker_iter_t, count) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_cache_iter_t {
    pub cur: *mut ecs_table_cache_hdr_t,
    pub next: *mut ecs_table_cache_hdr_t,
    pub next_list: *mut ecs_table_cache_hdr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_table_cache_iter_t"][::std::mem::size_of::<ecs_table_cache_iter_t>() - 24usize];
    ["Alignment of ecs_table_cache_iter_t"]
        [::std::mem::align_of::<ecs_table_cache_iter_t>() - 8usize];
    ["Offset of field: ecs_table_cache_iter_t::cur"]
        [::std::mem::offset_of!(ecs_table_cache_iter_t, cur) - 0usize];
    ["Offset of field: ecs_table_cache_iter_t::next"]
        [::std::mem::offset_of!(ecs_table_cache_iter_t, next) - 8usize];
    ["Offset of field: ecs_table_cache_iter_t::next_list"]
        [::std::mem::offset_of!(ecs_table_cache_iter_t, next_list) - 16usize];
};
#[doc = " Each iterator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_each_iter_t {
    pub it: ecs_table_cache_iter_t,
    pub ids: ecs_id_t,
    pub sources: ecs_entity_t,
    pub sizes: ecs_size_t,
    pub columns: i32,
    pub trs: *const ecs_table_record_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_each_iter_t"][::std::mem::size_of::<ecs_each_iter_t>() - 56usize];
    ["Alignment of ecs_each_iter_t"][::std::mem::align_of::<ecs_each_iter_t>() - 8usize];
    ["Offset of field: ecs_each_iter_t::it"][::std::mem::offset_of!(ecs_each_iter_t, it) - 0usize];
    ["Offset of field: ecs_each_iter_t::ids"]
        [::std::mem::offset_of!(ecs_each_iter_t, ids) - 24usize];
    ["Offset of field: ecs_each_iter_t::sources"]
        [::std::mem::offset_of!(ecs_each_iter_t, sources) - 32usize];
    ["Offset of field: ecs_each_iter_t::sizes"]
        [::std::mem::offset_of!(ecs_each_iter_t, sizes) - 40usize];
    ["Offset of field: ecs_each_iter_t::columns"]
        [::std::mem::offset_of!(ecs_each_iter_t, columns) - 44usize];
    ["Offset of field: ecs_each_iter_t::trs"]
        [::std::mem::offset_of!(ecs_each_iter_t, trs) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_op_profile_t {
    pub count: [i32; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_op_profile_t"][::std::mem::size_of::<ecs_query_op_profile_t>() - 8usize];
    ["Alignment of ecs_query_op_profile_t"]
        [::std::mem::align_of::<ecs_query_op_profile_t>() - 4usize];
    ["Offset of field: ecs_query_op_profile_t::count"]
        [::std::mem::offset_of!(ecs_query_op_profile_t, count) - 0usize];
};
#[doc = " Query iterator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_iter_t {
    pub query: *const ecs_query_t,
    pub vars: *mut ecs_var_t,
    pub query_vars: *mut ecs_query_var_t,
    pub ops: *mut ecs_query_op_t,
    pub op_ctx: *mut ecs_query_op_ctx_t,
    pub node: *mut ecs_query_cache_table_match_t,
    pub prev: *mut ecs_query_cache_table_match_t,
    pub last: *mut ecs_query_cache_table_match_t,
    pub written: *mut u64,
    pub skip_count: i32,
    pub profile: *mut ecs_query_op_profile_t,
    pub op: i16,
    pub sp: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_iter_t"][::std::mem::size_of::<ecs_query_iter_t>() - 96usize];
    ["Alignment of ecs_query_iter_t"][::std::mem::align_of::<ecs_query_iter_t>() - 8usize];
    ["Offset of field: ecs_query_iter_t::query"]
        [::std::mem::offset_of!(ecs_query_iter_t, query) - 0usize];
    ["Offset of field: ecs_query_iter_t::vars"]
        [::std::mem::offset_of!(ecs_query_iter_t, vars) - 8usize];
    ["Offset of field: ecs_query_iter_t::query_vars"]
        [::std::mem::offset_of!(ecs_query_iter_t, query_vars) - 16usize];
    ["Offset of field: ecs_query_iter_t::ops"]
        [::std::mem::offset_of!(ecs_query_iter_t, ops) - 24usize];
    ["Offset of field: ecs_query_iter_t::op_ctx"]
        [::std::mem::offset_of!(ecs_query_iter_t, op_ctx) - 32usize];
    ["Offset of field: ecs_query_iter_t::node"]
        [::std::mem::offset_of!(ecs_query_iter_t, node) - 40usize];
    ["Offset of field: ecs_query_iter_t::prev"]
        [::std::mem::offset_of!(ecs_query_iter_t, prev) - 48usize];
    ["Offset of field: ecs_query_iter_t::last"]
        [::std::mem::offset_of!(ecs_query_iter_t, last) - 56usize];
    ["Offset of field: ecs_query_iter_t::written"]
        [::std::mem::offset_of!(ecs_query_iter_t, written) - 64usize];
    ["Offset of field: ecs_query_iter_t::skip_count"]
        [::std::mem::offset_of!(ecs_query_iter_t, skip_count) - 72usize];
    ["Offset of field: ecs_query_iter_t::profile"]
        [::std::mem::offset_of!(ecs_query_iter_t, profile) - 80usize];
    ["Offset of field: ecs_query_iter_t::op"]
        [::std::mem::offset_of!(ecs_query_iter_t, op) - 88usize];
    ["Offset of field: ecs_query_iter_t::sp"]
        [::std::mem::offset_of!(ecs_query_iter_t, sp) - 90usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_iter_cache_t {
    pub stack_cursor: *mut ecs_stack_cursor_t,
    pub used: ecs_flags8_t,
    pub allocated: ecs_flags8_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_iter_cache_t"][::std::mem::size_of::<ecs_iter_cache_t>() - 16usize];
    ["Alignment of ecs_iter_cache_t"][::std::mem::align_of::<ecs_iter_cache_t>() - 8usize];
    ["Offset of field: ecs_iter_cache_t::stack_cursor"]
        [::std::mem::offset_of!(ecs_iter_cache_t, stack_cursor) - 0usize];
    ["Offset of field: ecs_iter_cache_t::used"]
        [::std::mem::offset_of!(ecs_iter_cache_t, used) - 8usize];
    ["Offset of field: ecs_iter_cache_t::allocated"]
        [::std::mem::offset_of!(ecs_iter_cache_t, allocated) - 9usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_iter_private_t {
    pub iter: ecs_iter_private_t__bindgen_ty_1,
    pub entity_iter: *mut ::std::os::raw::c_void,
    pub cache: ecs_iter_cache_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ecs_iter_private_t__bindgen_ty_1 {
    pub query: ecs_query_iter_t,
    pub page: ecs_page_iter_t,
    pub worker: ecs_worker_iter_t,
    pub each: ecs_each_iter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_iter_private_t__bindgen_ty_1"]
        [::std::mem::size_of::<ecs_iter_private_t__bindgen_ty_1>() - 96usize];
    ["Alignment of ecs_iter_private_t__bindgen_ty_1"]
        [::std::mem::align_of::<ecs_iter_private_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: ecs_iter_private_t__bindgen_ty_1::query"]
        [::std::mem::offset_of!(ecs_iter_private_t__bindgen_ty_1, query) - 0usize];
    ["Offset of field: ecs_iter_private_t__bindgen_ty_1::page"]
        [::std::mem::offset_of!(ecs_iter_private_t__bindgen_ty_1, page) - 0usize];
    ["Offset of field: ecs_iter_private_t__bindgen_ty_1::worker"]
        [::std::mem::offset_of!(ecs_iter_private_t__bindgen_ty_1, worker) - 0usize];
    ["Offset of field: ecs_iter_private_t__bindgen_ty_1::each"]
        [::std::mem::offset_of!(ecs_iter_private_t__bindgen_ty_1, each) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_iter_private_t"][::std::mem::size_of::<ecs_iter_private_t>() - 120usize];
    ["Alignment of ecs_iter_private_t"][::std::mem::align_of::<ecs_iter_private_t>() - 8usize];
    ["Offset of field: ecs_iter_private_t::iter"]
        [::std::mem::offset_of!(ecs_iter_private_t, iter) - 0usize];
    ["Offset of field: ecs_iter_private_t::entity_iter"]
        [::std::mem::offset_of!(ecs_iter_private_t, entity_iter) - 96usize];
    ["Offset of field: ecs_iter_private_t::cache"]
        [::std::mem::offset_of!(ecs_iter_private_t, cache) - 104usize];
};
extern "C" {
    pub fn flecs_module_path_from_c(
        c_name: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_identifier_is_0(id: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn flecs_default_ctor(
        ptr: *mut ::std::os::raw::c_void,
        count: i32,
        ctx: *const ecs_type_info_t,
    );
}
extern "C" {
    pub fn flecs_vasprintf(
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_asprintf(fmt: *const ::std::os::raw::c_char, ...) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write an escaped character.\n Write a character to an output string, insert escape character if necessary.\n\n @param out The string to write the character to.\n @param in The input character.\n @param delimiter The delimiter used (for example '\"')\n @return Pointer to the character after the last one written."]
    pub fn flecs_chresc(
        out: *mut ::std::os::raw::c_char,
        in_: ::std::os::raw::c_char,
        delimiter: ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse an escaped character.\n Parse a character with a potential escape sequence.\n\n @param in Pointer to character in input string.\n @param out Output string.\n @return Pointer to the character after the last one read."]
    pub fn flecs_chrparse(
        in_: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write an escaped string.\n Write an input string to an output string, escape characters where necessary.\n To determine the size of the output string, call the operation with a NULL\n argument for 'out', and use the returned size to allocate a string that is\n large enough.\n\n @param out Pointer to output string (must be).\n @param size Maximum number of characters written to output.\n @param delimiter The delimiter used (for example '\"').\n @param in The input string.\n @return The number of characters that (would) have been written."]
    pub fn flecs_stresc(
        out: *mut ::std::os::raw::c_char,
        size: ecs_size_t,
        delimiter: ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
    ) -> ecs_size_t;
}
extern "C" {
    #[doc = " Return escaped string.\n Return escaped version of input string. Same as flecs_stresc(), but returns an\n allocated string of the right size.\n\n @param delimiter The delimiter used (for example '\"').\n @param in The input string.\n @return Escaped string."]
    pub fn flecs_astresc(
        delimiter: ::std::os::raw::c_char,
        in_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Skip whitespace and newline characters.\n This function skips whitespace characters.\n\n @param ptr Pointer to (potential) whitespaces to skip.\n @return Pointer to the next non-whitespace character."]
    pub fn flecs_parse_ws_eol(ptr: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Parse digit.\n This function will parse until the first non-digit character is found. The\n provided expression must contain at least one digit character.\n\n @param ptr The expression to parse.\n @param token The output buffer.\n @return Pointer to the first non-digit character."]
    pub fn flecs_parse_digit(
        ptr: *const ::std::os::raw::c_char,
        token: *mut ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_to_snake_case(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flecs_table_observed_count(table: *const ecs_table_t) -> i32;
}
extern "C" {
    pub fn flecs_dump_backtrace(stream: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_suspend_readonly_state_t {
    pub is_readonly: bool,
    pub is_deferred: bool,
    pub defer_count: i32,
    pub scope: ecs_entity_t,
    pub with: ecs_entity_t,
    pub commands: ecs_vec_t,
    pub defer_stack: ecs_stack_t,
    pub stage: *mut ecs_stage_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_suspend_readonly_state_t"]
        [::std::mem::size_of::<ecs_suspend_readonly_state_t>() - 96usize];
    ["Alignment of ecs_suspend_readonly_state_t"]
        [::std::mem::align_of::<ecs_suspend_readonly_state_t>() - 8usize];
    ["Offset of field: ecs_suspend_readonly_state_t::is_readonly"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, is_readonly) - 0usize];
    ["Offset of field: ecs_suspend_readonly_state_t::is_deferred"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, is_deferred) - 1usize];
    ["Offset of field: ecs_suspend_readonly_state_t::defer_count"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, defer_count) - 4usize];
    ["Offset of field: ecs_suspend_readonly_state_t::scope"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, scope) - 8usize];
    ["Offset of field: ecs_suspend_readonly_state_t::with"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, with) - 16usize];
    ["Offset of field: ecs_suspend_readonly_state_t::commands"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, commands) - 24usize];
    ["Offset of field: ecs_suspend_readonly_state_t::defer_stack"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, defer_stack) - 40usize];
    ["Offset of field: ecs_suspend_readonly_state_t::stage"]
        [::std::mem::offset_of!(ecs_suspend_readonly_state_t, stage) - 88usize];
};
extern "C" {
    pub fn flecs_suspend_readonly(
        world: *const ecs_world_t,
        state: *mut ecs_suspend_readonly_state_t,
    ) -> *mut ecs_world_t;
}
extern "C" {
    pub fn flecs_resume_readonly(world: *mut ecs_world_t, state: *mut ecs_suspend_readonly_state_t);
}
extern "C" {
    pub fn flecs_poly_claim_(poly: *mut ecs_poly_t) -> i32;
}
extern "C" {
    pub fn flecs_poly_release_(poly: *mut ecs_poly_t) -> i32;
}
extern "C" {
    pub fn flecs_poly_refcount(poly: *mut ecs_poly_t) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_hm_bucket_t {
    pub keys: ecs_vec_t,
    pub values: ecs_vec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_hm_bucket_t"][::std::mem::size_of::<ecs_hm_bucket_t>() - 32usize];
    ["Alignment of ecs_hm_bucket_t"][::std::mem::align_of::<ecs_hm_bucket_t>() - 8usize];
    ["Offset of field: ecs_hm_bucket_t::keys"]
        [::std::mem::offset_of!(ecs_hm_bucket_t, keys) - 0usize];
    ["Offset of field: ecs_hm_bucket_t::values"]
        [::std::mem::offset_of!(ecs_hm_bucket_t, values) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_hashmap_t {
    pub hash: ecs_hash_value_action_t,
    pub compare: ecs_compare_action_t,
    pub key_size: ecs_size_t,
    pub value_size: ecs_size_t,
    pub hashmap_allocator: *mut ecs_block_allocator_t,
    pub bucket_allocator: ecs_block_allocator_t,
    pub impl_: ecs_map_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_hashmap_t"][::std::mem::size_of::<ecs_hashmap_t>() - 120usize];
    ["Alignment of ecs_hashmap_t"][::std::mem::align_of::<ecs_hashmap_t>() - 8usize];
    ["Offset of field: ecs_hashmap_t::hash"][::std::mem::offset_of!(ecs_hashmap_t, hash) - 0usize];
    ["Offset of field: ecs_hashmap_t::compare"]
        [::std::mem::offset_of!(ecs_hashmap_t, compare) - 8usize];
    ["Offset of field: ecs_hashmap_t::key_size"]
        [::std::mem::offset_of!(ecs_hashmap_t, key_size) - 16usize];
    ["Offset of field: ecs_hashmap_t::value_size"]
        [::std::mem::offset_of!(ecs_hashmap_t, value_size) - 20usize];
    ["Offset of field: ecs_hashmap_t::hashmap_allocator"]
        [::std::mem::offset_of!(ecs_hashmap_t, hashmap_allocator) - 24usize];
    ["Offset of field: ecs_hashmap_t::bucket_allocator"]
        [::std::mem::offset_of!(ecs_hashmap_t, bucket_allocator) - 32usize];
    ["Offset of field: ecs_hashmap_t::impl_"]
        [::std::mem::offset_of!(ecs_hashmap_t, impl_) - 80usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flecs_hashmap_iter_t {
    pub it: ecs_map_iter_t,
    pub bucket: *mut ecs_hm_bucket_t,
    pub index: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flecs_hashmap_iter_t"][::std::mem::size_of::<flecs_hashmap_iter_t>() - 48usize];
    ["Alignment of flecs_hashmap_iter_t"][::std::mem::align_of::<flecs_hashmap_iter_t>() - 8usize];
    ["Offset of field: flecs_hashmap_iter_t::it"]
        [::std::mem::offset_of!(flecs_hashmap_iter_t, it) - 0usize];
    ["Offset of field: flecs_hashmap_iter_t::bucket"]
        [::std::mem::offset_of!(flecs_hashmap_iter_t, bucket) - 32usize];
    ["Offset of field: flecs_hashmap_iter_t::index"]
        [::std::mem::offset_of!(flecs_hashmap_iter_t, index) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flecs_hashmap_result_t {
    pub key: *mut ::std::os::raw::c_void,
    pub value: *mut ::std::os::raw::c_void,
    pub hash: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of flecs_hashmap_result_t"][::std::mem::size_of::<flecs_hashmap_result_t>() - 24usize];
    ["Alignment of flecs_hashmap_result_t"]
        [::std::mem::align_of::<flecs_hashmap_result_t>() - 8usize];
    ["Offset of field: flecs_hashmap_result_t::key"]
        [::std::mem::offset_of!(flecs_hashmap_result_t, key) - 0usize];
    ["Offset of field: flecs_hashmap_result_t::value"]
        [::std::mem::offset_of!(flecs_hashmap_result_t, value) - 8usize];
    ["Offset of field: flecs_hashmap_result_t::hash"]
        [::std::mem::offset_of!(flecs_hashmap_result_t, hash) - 16usize];
};
extern "C" {
    pub fn flecs_hashmap_init_(
        hm: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        value_size: ecs_size_t,
        hash: ecs_hash_value_action_t,
        compare: ecs_compare_action_t,
        allocator: *mut ecs_allocator_t,
    );
}
extern "C" {
    pub fn flecs_hashmap_fini(map: *mut ecs_hashmap_t);
}
extern "C" {
    pub fn flecs_hashmap_get_(
        map: *const ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn flecs_hashmap_ensure_(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
    ) -> flecs_hashmap_result_t;
}
extern "C" {
    pub fn flecs_hashmap_set_(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *mut ::std::os::raw::c_void,
        value_size: ecs_size_t,
        value: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn flecs_hashmap_remove_(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
    );
}
extern "C" {
    pub fn flecs_hashmap_remove_w_hash_(
        map: *mut ecs_hashmap_t,
        key_size: ecs_size_t,
        key: *const ::std::os::raw::c_void,
        value_size: ecs_size_t,
        hash: u64,
    );
}
extern "C" {
    pub fn flecs_hashmap_get_bucket(map: *const ecs_hashmap_t, hash: u64) -> *mut ecs_hm_bucket_t;
}
extern "C" {
    pub fn flecs_hm_bucket_remove(
        map: *mut ecs_hashmap_t,
        bucket: *mut ecs_hm_bucket_t,
        hash: u64,
        index: i32,
    );
}
extern "C" {
    pub fn flecs_hashmap_copy(dst: *mut ecs_hashmap_t, src: *const ecs_hashmap_t);
}
extern "C" {
    pub fn flecs_hashmap_iter(map: *mut ecs_hashmap_t) -> flecs_hashmap_iter_t;
}
extern "C" {
    pub fn flecs_hashmap_next_(
        it: *mut flecs_hashmap_iter_t,
        key_size: ecs_size_t,
        key_out: *mut ::std::os::raw::c_void,
        value_size: ecs_size_t,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Utility to hold a value of a dynamic type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_value_t {
    #[doc = "< Type of value."]
    pub type_: ecs_entity_t,
    #[doc = "< Pointer to value."]
    pub ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_value_t"][::std::mem::size_of::<ecs_value_t>() - 16usize];
    ["Alignment of ecs_value_t"][::std::mem::align_of::<ecs_value_t>() - 8usize];
    ["Offset of field: ecs_value_t::type_"][::std::mem::offset_of!(ecs_value_t, type_) - 0usize];
    ["Offset of field: ecs_value_t::ptr"][::std::mem::offset_of!(ecs_value_t, ptr) - 8usize];
};
#[doc = " Used with ecs_entity_init().\n\n @ingroup entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_entity_desc_t {
    #[doc = "< Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = "< Set to modify existing entity (optional)"]
    pub id: ecs_entity_t,
    #[doc = "< Parent entity."]
    pub parent: ecs_entity_t,
    #[doc = "< Name of the entity. If no entity is provided, an\n entity with this name will be looked up first. When\n an entity is provided, the name will be verified\n with the existing entity."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Optional custom separator for hierarchical names.\n Leave to NULL for default ('.') separator. Set to\n an empty string to prevent tokenization of name."]
    pub sep: *const ::std::os::raw::c_char,
    #[doc = "< Optional, used for identifiers relative to root"]
    pub root_sep: *const ::std::os::raw::c_char,
    #[doc = "< Optional entity symbol. A symbol is an unscoped\n identifier that can be used to lookup an entity. The\n primary use case for this is to associate the entity\n with a language identifier, such as a type or\n function name, where these identifiers differ from\n the name they are registered with in flecs. For\n example, C type \"EcsPosition\" might be registered\n as \"flecs.components.transform.Position\", with the\n symbol set to \"EcsPosition\"."]
    pub symbol: *const ::std::os::raw::c_char,
    #[doc = "< When set to true, a low id (typically reserved for\n components) will be used to create the entity, if\n no id is specified."]
    pub use_low_id: bool,
    #[doc = " 0-terminated array of ids to add to the entity."]
    pub add: *const ecs_id_t,
    #[doc = " 0-terminated array of values to set on the entity."]
    pub set: *const ecs_value_t,
    #[doc = " String expression with components to add"]
    pub add_expr: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_entity_desc_t"][::std::mem::size_of::<ecs_entity_desc_t>() - 88usize];
    ["Alignment of ecs_entity_desc_t"][::std::mem::align_of::<ecs_entity_desc_t>() - 8usize];
    ["Offset of field: ecs_entity_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_entity_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_entity_desc_t::id"]
        [::std::mem::offset_of!(ecs_entity_desc_t, id) - 8usize];
    ["Offset of field: ecs_entity_desc_t::parent"]
        [::std::mem::offset_of!(ecs_entity_desc_t, parent) - 16usize];
    ["Offset of field: ecs_entity_desc_t::name"]
        [::std::mem::offset_of!(ecs_entity_desc_t, name) - 24usize];
    ["Offset of field: ecs_entity_desc_t::sep"]
        [::std::mem::offset_of!(ecs_entity_desc_t, sep) - 32usize];
    ["Offset of field: ecs_entity_desc_t::root_sep"]
        [::std::mem::offset_of!(ecs_entity_desc_t, root_sep) - 40usize];
    ["Offset of field: ecs_entity_desc_t::symbol"]
        [::std::mem::offset_of!(ecs_entity_desc_t, symbol) - 48usize];
    ["Offset of field: ecs_entity_desc_t::use_low_id"]
        [::std::mem::offset_of!(ecs_entity_desc_t, use_low_id) - 56usize];
    ["Offset of field: ecs_entity_desc_t::add"]
        [::std::mem::offset_of!(ecs_entity_desc_t, add) - 64usize];
    ["Offset of field: ecs_entity_desc_t::set"]
        [::std::mem::offset_of!(ecs_entity_desc_t, set) - 72usize];
    ["Offset of field: ecs_entity_desc_t::add_expr"]
        [::std::mem::offset_of!(ecs_entity_desc_t, add_expr) - 80usize];
};
#[doc = " Used with ecs_bulk_init().\n\n @ingroup entities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_bulk_desc_t {
    #[doc = "< Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = "< Entities to bulk insert. Entity ids provided by\n the application must be empty (cannot\n have components). If no entity ids are provided, the\n operation will create 'count' new entities."]
    pub entities: *mut ecs_entity_t,
    #[doc = "< Number of entities to create/populate"]
    pub count: i32,
    #[doc = "< Ids to create the entities with"]
    pub ids: [ecs_id_t; 32usize],
    #[doc = "< Array with component data to insert. Each element in\n the array must correspond with an element in the ids\n array. If an element in the ids array is a tag, the\n data array must contain a NULL. An element may be\n set to NULL for a component, in which case the\n component will not be set by the operation."]
    pub data: *mut *mut ::std::os::raw::c_void,
    #[doc = "< Table to insert the entities into. Should not be set\n at the same time as ids. When 'table' is set at the\n same time as 'data', the elements in the data array\n must correspond with the ids in the table's type."]
    pub table: *mut ecs_table_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_bulk_desc_t"][::std::mem::size_of::<ecs_bulk_desc_t>() - 296usize];
    ["Alignment of ecs_bulk_desc_t"][::std::mem::align_of::<ecs_bulk_desc_t>() - 8usize];
    ["Offset of field: ecs_bulk_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_bulk_desc_t::entities"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, entities) - 8usize];
    ["Offset of field: ecs_bulk_desc_t::count"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, count) - 16usize];
    ["Offset of field: ecs_bulk_desc_t::ids"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, ids) - 24usize];
    ["Offset of field: ecs_bulk_desc_t::data"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, data) - 280usize];
    ["Offset of field: ecs_bulk_desc_t::table"]
        [::std::mem::offset_of!(ecs_bulk_desc_t, table) - 288usize];
};
#[doc = " Used with ecs_component_init().\n\n @ingroup components"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_component_desc_t {
    #[doc = "< Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = " Existing entity to associate with observer (optional)"]
    pub entity: ecs_entity_t,
    #[doc = " Parameters for type (size, hooks, ...)"]
    pub type_: ecs_type_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_component_desc_t"][::std::mem::size_of::<ecs_component_desc_t>() - 160usize];
    ["Alignment of ecs_component_desc_t"][::std::mem::align_of::<ecs_component_desc_t>() - 8usize];
    ["Offset of field: ecs_component_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_component_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_component_desc_t::entity"]
        [::std::mem::offset_of!(ecs_component_desc_t, entity) - 8usize];
    ["Offset of field: ecs_component_desc_t::type_"]
        [::std::mem::offset_of!(ecs_component_desc_t, type_) - 16usize];
};
#[doc = " Iterator.\n Used for iterating queries. The ecs_iter_t type contains all the information\n that is provided by a query, and contains all the state required for the\n iterator code.\n\n Functions that create iterators accept as first argument the world, and as\n second argument the object they iterate. For example:\n\n @code\n ecs_iter_t it = ecs_query_iter(world, q);\n @endcode\n\n When this code is called from a system, it is important to use the world\n provided by its iterator object to ensure thread safety. For example:\n\n @code\n void Collide(ecs_iter_t *it) {\n   ecs_iter_t qit = ecs_query_iter(it->world, Colliders);\n }\n @endcode\n\n An iterator contains resources that need to be released. By default this\n is handled by the last call to next() that returns false. When iteration is\n ended before iteration has completed, an application has to manually call\n ecs_iter_fini() to release the iterator resources:\n\n @code\n ecs_iter_t it = ecs_query_iter(world, q);\n while (ecs_query_next(&it)) {\n   if (cond) {\n     ecs_iter_fini(&it);\n     break;\n   }\n }\n @endcode\n\n @ingroup queries"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecs_iter_t {
    #[doc = "< The world. Can point to stage when in deferred/readonly mode."]
    pub world: *mut ecs_world_t,
    #[doc = "< Actual world. Never points to a stage."]
    pub real_world: *mut ecs_world_t,
    #[doc = "< Entity identifiers"]
    pub entities: *const ecs_entity_t,
    #[doc = "< Component sizes"]
    pub sizes: *const ecs_size_t,
    #[doc = "< Current table"]
    pub table: *mut ecs_table_t,
    #[doc = "< Prev or next table when adding/removing"]
    pub other_table: *mut ecs_table_t,
    #[doc = "< (Component) ids"]
    pub ids: *mut ecs_id_t,
    #[doc = "< Values of variables (if any)"]
    pub variables: *mut ecs_var_t,
    #[doc = "< Info on where to find field in table"]
    pub trs: *mut *const ecs_table_record_t,
    #[doc = "< Entity on which the id was matched (0 if same as entities)"]
    pub sources: *mut ecs_entity_t,
    #[doc = "< Bitset that marks constrained variables"]
    pub constrained_vars: ecs_flags64_t,
    #[doc = "< Group id for table, if group_by is used"]
    pub group_id: u64,
    #[doc = "< Fields that are set"]
    pub set_fields: ecs_flags32_t,
    #[doc = "< Bitset with fields that aren't component arrays"]
    pub ref_fields: ecs_flags32_t,
    #[doc = "< Fields that must be obtained with field_at"]
    pub row_fields: ecs_flags32_t,
    #[doc = "< Bitset with fields matched through up traversal"]
    pub up_fields: ecs_flags32_t,
    #[doc = "< The system (if applicable)"]
    pub system: ecs_entity_t,
    #[doc = "< The event (if applicable)"]
    pub event: ecs_entity_t,
    #[doc = "< The (component) id for the event"]
    pub event_id: ecs_id_t,
    #[doc = "< Unique event id. Used to dedup observer calls"]
    pub event_cur: i32,
    #[doc = "< Number of fields in iterator"]
    pub field_count: i8,
    #[doc = "< Index of term that emitted an event.\n This field will be set to the 'index' field\n of an observer term."]
    pub term_index: i8,
    #[doc = "< Number of variables for query"]
    pub variable_count: i8,
    #[doc = "< Query being evaluated"]
    pub query: *const ecs_query_t,
    #[doc = "< Names of variables (if any)"]
    pub variable_names: *mut *mut ::std::os::raw::c_char,
    #[doc = "< Param passed to ecs_run"]
    pub param: *mut ::std::os::raw::c_void,
    #[doc = "< System context"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "< System binding context"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Callback language binding context"]
    pub callback_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Run language binding context"]
    pub run_ctx: *mut ::std::os::raw::c_void,
    #[doc = "< Time elapsed since last frame"]
    pub delta_time: f32,
    #[doc = "< Time elapsed since last system invocation"]
    pub delta_system_time: f32,
    #[doc = "< Offset relative to start of iteration"]
    pub frame_offset: i32,
    #[doc = "< Offset relative to current table"]
    pub offset: i32,
    #[doc = "< Number of entities to iterate"]
    pub count: i32,
    #[doc = "< Iterator flags"]
    pub flags: ecs_flags32_t,
    #[doc = "< When set, system execution is interrupted"]
    pub interrupted_by: ecs_entity_t,
    #[doc = "< Private data"]
    pub priv_: ecs_iter_private_t,
    #[doc = "< Function to progress iterator"]
    pub next: ecs_iter_next_action_t,
    #[doc = "< Callback of system or observer"]
    pub callback: ecs_iter_action_t,
    #[doc = "< Function to cleanup iterator resources"]
    pub fini: ecs_iter_fini_action_t,
    #[doc = "< Optional, allows for creating iterator chains"]
    pub chain_it: *mut ecs_iter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_iter_t"][::std::mem::size_of::<ecs_iter_t>() - 384usize];
    ["Alignment of ecs_iter_t"][::std::mem::align_of::<ecs_iter_t>() - 8usize];
    ["Offset of field: ecs_iter_t::world"][::std::mem::offset_of!(ecs_iter_t, world) - 0usize];
    ["Offset of field: ecs_iter_t::real_world"]
        [::std::mem::offset_of!(ecs_iter_t, real_world) - 8usize];
    ["Offset of field: ecs_iter_t::entities"]
        [::std::mem::offset_of!(ecs_iter_t, entities) - 16usize];
    ["Offset of field: ecs_iter_t::sizes"][::std::mem::offset_of!(ecs_iter_t, sizes) - 24usize];
    ["Offset of field: ecs_iter_t::table"][::std::mem::offset_of!(ecs_iter_t, table) - 32usize];
    ["Offset of field: ecs_iter_t::other_table"]
        [::std::mem::offset_of!(ecs_iter_t, other_table) - 40usize];
    ["Offset of field: ecs_iter_t::ids"][::std::mem::offset_of!(ecs_iter_t, ids) - 48usize];
    ["Offset of field: ecs_iter_t::variables"]
        [::std::mem::offset_of!(ecs_iter_t, variables) - 56usize];
    ["Offset of field: ecs_iter_t::trs"][::std::mem::offset_of!(ecs_iter_t, trs) - 64usize];
    ["Offset of field: ecs_iter_t::sources"][::std::mem::offset_of!(ecs_iter_t, sources) - 72usize];
    ["Offset of field: ecs_iter_t::constrained_vars"]
        [::std::mem::offset_of!(ecs_iter_t, constrained_vars) - 80usize];
    ["Offset of field: ecs_iter_t::group_id"]
        [::std::mem::offset_of!(ecs_iter_t, group_id) - 88usize];
    ["Offset of field: ecs_iter_t::set_fields"]
        [::std::mem::offset_of!(ecs_iter_t, set_fields) - 96usize];
    ["Offset of field: ecs_iter_t::ref_fields"]
        [::std::mem::offset_of!(ecs_iter_t, ref_fields) - 100usize];
    ["Offset of field: ecs_iter_t::row_fields"]
        [::std::mem::offset_of!(ecs_iter_t, row_fields) - 104usize];
    ["Offset of field: ecs_iter_t::up_fields"]
        [::std::mem::offset_of!(ecs_iter_t, up_fields) - 108usize];
    ["Offset of field: ecs_iter_t::system"][::std::mem::offset_of!(ecs_iter_t, system) - 112usize];
    ["Offset of field: ecs_iter_t::event"][::std::mem::offset_of!(ecs_iter_t, event) - 120usize];
    ["Offset of field: ecs_iter_t::event_id"]
        [::std::mem::offset_of!(ecs_iter_t, event_id) - 128usize];
    ["Offset of field: ecs_iter_t::event_cur"]
        [::std::mem::offset_of!(ecs_iter_t, event_cur) - 136usize];
    ["Offset of field: ecs_iter_t::field_count"]
        [::std::mem::offset_of!(ecs_iter_t, field_count) - 140usize];
    ["Offset of field: ecs_iter_t::term_index"]
        [::std::mem::offset_of!(ecs_iter_t, term_index) - 141usize];
    ["Offset of field: ecs_iter_t::variable_count"]
        [::std::mem::offset_of!(ecs_iter_t, variable_count) - 142usize];
    ["Offset of field: ecs_iter_t::query"][::std::mem::offset_of!(ecs_iter_t, query) - 144usize];
    ["Offset of field: ecs_iter_t::variable_names"]
        [::std::mem::offset_of!(ecs_iter_t, variable_names) - 152usize];
    ["Offset of field: ecs_iter_t::param"][::std::mem::offset_of!(ecs_iter_t, param) - 160usize];
    ["Offset of field: ecs_iter_t::ctx"][::std::mem::offset_of!(ecs_iter_t, ctx) - 168usize];
    ["Offset of field: ecs_iter_t::binding_ctx"]
        [::std::mem::offset_of!(ecs_iter_t, binding_ctx) - 176usize];
    ["Offset of field: ecs_iter_t::callback_ctx"]
        [::std::mem::offset_of!(ecs_iter_t, callback_ctx) - 184usize];
    ["Offset of field: ecs_iter_t::run_ctx"]
        [::std::mem::offset_of!(ecs_iter_t, run_ctx) - 192usize];
    ["Offset of field: ecs_iter_t::delta_time"]
        [::std::mem::offset_of!(ecs_iter_t, delta_time) - 200usize];
    ["Offset of field: ecs_iter_t::delta_system_time"]
        [::std::mem::offset_of!(ecs_iter_t, delta_system_time) - 204usize];
    ["Offset of field: ecs_iter_t::frame_offset"]
        [::std::mem::offset_of!(ecs_iter_t, frame_offset) - 208usize];
    ["Offset of field: ecs_iter_t::offset"][::std::mem::offset_of!(ecs_iter_t, offset) - 212usize];
    ["Offset of field: ecs_iter_t::count"][::std::mem::offset_of!(ecs_iter_t, count) - 216usize];
    ["Offset of field: ecs_iter_t::flags"][::std::mem::offset_of!(ecs_iter_t, flags) - 220usize];
    ["Offset of field: ecs_iter_t::interrupted_by"]
        [::std::mem::offset_of!(ecs_iter_t, interrupted_by) - 224usize];
    ["Offset of field: ecs_iter_t::priv_"][::std::mem::offset_of!(ecs_iter_t, priv_) - 232usize];
    ["Offset of field: ecs_iter_t::next"][::std::mem::offset_of!(ecs_iter_t, next) - 352usize];
    ["Offset of field: ecs_iter_t::callback"]
        [::std::mem::offset_of!(ecs_iter_t, callback) - 360usize];
    ["Offset of field: ecs_iter_t::fini"][::std::mem::offset_of!(ecs_iter_t, fini) - 368usize];
    ["Offset of field: ecs_iter_t::chain_it"]
        [::std::mem::offset_of!(ecs_iter_t, chain_it) - 376usize];
};
#[doc = " Used with ecs_query_init().\n\n \\ingroup queries"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_desc_t {
    #[doc = " Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = " Query terms"]
    pub terms: [ecs_term_t; 32usize],
    #[doc = " Query DSL expression (optional)"]
    pub expr: *const ::std::os::raw::c_char,
    #[doc = " Caching policy of query"]
    pub cache_kind: ecs_query_cache_kind_t,
    #[doc = " Flags for enabling query features"]
    pub flags: ecs_flags32_t,
    #[doc = " Callback used for ordering query results. If order_by_id is 0, the\n pointer provided to the callback will be NULL. If the callback is not\n set, results will not be ordered."]
    pub order_by_callback: ecs_order_by_action_t,
    #[doc = " Callback used for ordering query results. Same as order_by_callback,\n but more efficient."]
    pub order_by_table_callback: ecs_sort_table_action_t,
    #[doc = " Component to sort on, used together with order_by_callback or\n order_by_table_callback."]
    pub order_by: ecs_entity_t,
    #[doc = " Component id to be used for grouping. Used together with the\n group_by_callback."]
    pub group_by: ecs_id_t,
    #[doc = " Callback used for grouping results. If the callback is not set, results\n will not be grouped. When set, this callback will be used to calculate a\n \"rank\" for each entity (table) based on its components. This rank is then\n used to sort entities (tables), so that entities (tables) of the same\n rank are \"grouped\" together when iterated."]
    pub group_by_callback: ecs_group_by_action_t,
    #[doc = " Callback that is invoked when a new group is created. The return value of\n the callback is stored as context for a group."]
    pub on_group_create: ecs_group_create_action_t,
    #[doc = " Callback that is invoked when an existing group is deleted. The return\n value of the on_group_create callback is passed as context parameter."]
    pub on_group_delete: ecs_group_delete_action_t,
    #[doc = " Context to pass to group_by"]
    pub group_by_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Function to free group_by_ctx"]
    pub group_by_ctx_free: ecs_ctx_free_t,
    #[doc = " User context to pass to callback"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " Context to be used for language bindings"]
    pub binding_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = " Callback to free binding_ctx"]
    pub binding_ctx_free: ecs_ctx_free_t,
    #[doc = " Entity associated with query (optional)"]
    pub entity: ecs_entity_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_desc_t"][::std::mem::size_of::<ecs_query_desc_t>() - 2440usize];
    ["Alignment of ecs_query_desc_t"][::std::mem::align_of::<ecs_query_desc_t>() - 8usize];
    ["Offset of field: ecs_query_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_query_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_query_desc_t::terms"]
        [::std::mem::offset_of!(ecs_query_desc_t, terms) - 8usize];
    ["Offset of field: ecs_query_desc_t::expr"]
        [::std::mem::offset_of!(ecs_query_desc_t, expr) - 2312usize];
    ["Offset of field: ecs_query_desc_t::cache_kind"]
        [::std::mem::offset_of!(ecs_query_desc_t, cache_kind) - 2320usize];
    ["Offset of field: ecs_query_desc_t::flags"]
        [::std::mem::offset_of!(ecs_query_desc_t, flags) - 2324usize];
    ["Offset of field: ecs_query_desc_t::order_by_callback"]
        [::std::mem::offset_of!(ecs_query_desc_t, order_by_callback) - 2328usize];
    ["Offset of field: ecs_query_desc_t::order_by_table_callback"]
        [::std::mem::offset_of!(ecs_query_desc_t, order_by_table_callback) - 2336usize];
    ["Offset of field: ecs_query_desc_t::order_by"]
        [::std::mem::offset_of!(ecs_query_desc_t, order_by) - 2344usize];
    ["Offset of field: ecs_query_desc_t::group_by"]
        [::std::mem::offset_of!(ecs_query_desc_t, group_by) - 2352usize];
    ["Offset of field: ecs_query_desc_t::group_by_callback"]
        [::std::mem::offset_of!(ecs_query_desc_t, group_by_callback) - 2360usize];
    ["Offset of field: ecs_query_desc_t::on_group_create"]
        [::std::mem::offset_of!(ecs_query_desc_t, on_group_create) - 2368usize];
    ["Offset of field: ecs_query_desc_t::on_group_delete"]
        [::std::mem::offset_of!(ecs_query_desc_t, on_group_delete) - 2376usize];
    ["Offset of field: ecs_query_desc_t::group_by_ctx"]
        [::std::mem::offset_of!(ecs_query_desc_t, group_by_ctx) - 2384usize];
    ["Offset of field: ecs_query_desc_t::group_by_ctx_free"]
        [::std::mem::offset_of!(ecs_query_desc_t, group_by_ctx_free) - 2392usize];
    ["Offset of field: ecs_query_desc_t::ctx"]
        [::std::mem::offset_of!(ecs_query_desc_t, ctx) - 2400usize];
    ["Offset of field: ecs_query_desc_t::binding_ctx"]
        [::std::mem::offset_of!(ecs_query_desc_t, binding_ctx) - 2408usize];
    ["Offset of field: ecs_query_desc_t::ctx_free"]
        [::std::mem::offset_of!(ecs_query_desc_t, ctx_free) - 2416usize];
    ["Offset of field: ecs_query_desc_t::binding_ctx_free"]
        [::std::mem::offset_of!(ecs_query_desc_t, binding_ctx_free) - 2424usize];
    ["Offset of field: ecs_query_desc_t::entity"]
        [::std::mem::offset_of!(ecs_query_desc_t, entity) - 2432usize];
};
#[doc = " Used with ecs_observer_init().\n\n @ingroup observers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_observer_desc_t {
    #[doc = " Used for validity testing. Must be 0."]
    pub _canary: i32,
    #[doc = " Existing entity to associate with observer (optional)"]
    pub entity: ecs_entity_t,
    #[doc = " Query for observer"]
    pub query: ecs_query_desc_t,
    #[doc = " Events to observe (OnAdd, OnRemove, OnSet)"]
    pub events: [ecs_entity_t; 8usize],
    #[doc = " When observer is created, generate events from existing data. For example,\n #EcsOnAdd `Position` would match all existing instances of `Position`."]
    pub yield_existing: bool,
    #[doc = " Callback to invoke on an event, invoked when the observer matches."]
    pub callback: ecs_iter_action_t,
    #[doc = " Callback invoked on an event. When left to NULL the default runner\n is used which matches the event with the observer's query, and calls\n 'callback' when it matches.\n A reason to override the run function is to improve performance, if there\n are more efficient way to test whether an event matches the observer than\n the general purpose query matcher."]
    pub run: ecs_run_action_t,
    #[doc = " User context to pass to callback"]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free ctx"]
    pub ctx_free: ecs_ctx_free_t,
    #[doc = " Context associated with callback (for language bindings)."]
    pub callback_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free callback ctx."]
    pub callback_ctx_free: ecs_ctx_free_t,
    #[doc = " Context associated with run (for language bindings)."]
    pub run_ctx: *mut ::std::os::raw::c_void,
    #[doc = " Callback to free run ctx."]
    pub run_ctx_free: ecs_ctx_free_t,
    #[doc = " Observable with which to register the observer"]
    pub observable: *mut ecs_poly_t,
    #[doc = " Optional shared last event id for multiple observers. Ensures only one\n of the observers with the shared id gets triggered for an event"]
    pub last_event_id: *mut i32,
    #[doc = " Used for internal purposes"]
    pub term_index_: i8,
    pub flags_: ecs_flags32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_observer_desc_t"][::std::mem::size_of::<ecs_observer_desc_t>() - 2616usize];
    ["Alignment of ecs_observer_desc_t"][::std::mem::align_of::<ecs_observer_desc_t>() - 8usize];
    ["Offset of field: ecs_observer_desc_t::_canary"]
        [::std::mem::offset_of!(ecs_observer_desc_t, _canary) - 0usize];
    ["Offset of field: ecs_observer_desc_t::entity"]
        [::std::mem::offset_of!(ecs_observer_desc_t, entity) - 8usize];
    ["Offset of field: ecs_observer_desc_t::query"]
        [::std::mem::offset_of!(ecs_observer_desc_t, query) - 16usize];
    ["Offset of field: ecs_observer_desc_t::events"]
        [::std::mem::offset_of!(ecs_observer_desc_t, events) - 2456usize];
    ["Offset of field: ecs_observer_desc_t::yield_existing"]
        [::std::mem::offset_of!(ecs_observer_desc_t, yield_existing) - 2520usize];
    ["Offset of field: ecs_observer_desc_t::callback"]
        [::std::mem::offset_of!(ecs_observer_desc_t, callback) - 2528usize];
    ["Offset of field: ecs_observer_desc_t::run"]
        [::std::mem::offset_of!(ecs_observer_desc_t, run) - 2536usize];
    ["Offset of field: ecs_observer_desc_t::ctx"]
        [::std::mem::offset_of!(ecs_observer_desc_t, ctx) - 2544usize];
    ["Offset of field: ecs_observer_desc_t::ctx_free"]
        [::std::mem::offset_of!(ecs_observer_desc_t, ctx_free) - 2552usize];
    ["Offset of field: ecs_observer_desc_t::callback_ctx"]
        [::std::mem::offset_of!(ecs_observer_desc_t, callback_ctx) - 2560usize];
    ["Offset of field: ecs_observer_desc_t::callback_ctx_free"]
        [::std::mem::offset_of!(ecs_observer_desc_t, callback_ctx_free) - 2568usize];
    ["Offset of field: ecs_observer_desc_t::run_ctx"]
        [::std::mem::offset_of!(ecs_observer_desc_t, run_ctx) - 2576usize];
    ["Offset of field: ecs_observer_desc_t::run_ctx_free"]
        [::std::mem::offset_of!(ecs_observer_desc_t, run_ctx_free) - 2584usize];
    ["Offset of field: ecs_observer_desc_t::observable"]
        [::std::mem::offset_of!(ecs_observer_desc_t, observable) - 2592usize];
    ["Offset of field: ecs_observer_desc_t::last_event_id"]
        [::std::mem::offset_of!(ecs_observer_desc_t, last_event_id) - 2600usize];
    ["Offset of field: ecs_observer_desc_t::term_index_"]
        [::std::mem::offset_of!(ecs_observer_desc_t, term_index_) - 2608usize];
    ["Offset of field: ecs_observer_desc_t::flags_"]
        [::std::mem::offset_of!(ecs_observer_desc_t, flags_) - 2612usize];
};
#[doc = " Used with ecs_emit().\n\n @ingroup observers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_event_desc_t {
    #[doc = " The event id. Only observers for the specified event will be notified"]
    pub event: ecs_entity_t,
    #[doc = " Component ids. Only observers with a matching component id will be\n notified. Observers are guaranteed to get notified once, even if they\n match more than one id."]
    pub ids: *const ecs_type_t,
    #[doc = " The table for which to notify."]
    pub table: *mut ecs_table_t,
    #[doc = " Optional 2nd table to notify. This can be used to communicate the\n previous or next table, in case an entity is moved between tables."]
    pub other_table: *mut ecs_table_t,
    #[doc = " Limit notified entities to ones starting from offset (row) in table"]
    pub offset: i32,
    #[doc = " Limit number of notified entities to count. offset+count must be less\n than the total number of entities in the table. If left to 0, it will be\n automatically determined by doing `ecs_table_count(table) - offset`."]
    pub count: i32,
    #[doc = " Single-entity alternative to setting table / offset / count"]
    pub entity: ecs_entity_t,
    #[doc = " Optional context.\n The type of the param must be the event, where the event is a component.\n When an event is enqueued, the value of param is coped to a temporary\n storage of the event type."]
    pub param: *mut ::std::os::raw::c_void,
    #[doc = " Same as param, but with the guarantee that the value won't be modified.\n When an event with a const parameter is enqueued, the value of the param\n is copied to a temporary storage of the event type."]
    pub const_param: *const ::std::os::raw::c_void,
    #[doc = " Observable (usually the world)"]
    pub observable: *mut ecs_poly_t,
    #[doc = " Event flags"]
    pub flags: ecs_flags32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_event_desc_t"][::std::mem::size_of::<ecs_event_desc_t>() - 80usize];
    ["Alignment of ecs_event_desc_t"][::std::mem::align_of::<ecs_event_desc_t>() - 8usize];
    ["Offset of field: ecs_event_desc_t::event"]
        [::std::mem::offset_of!(ecs_event_desc_t, event) - 0usize];
    ["Offset of field: ecs_event_desc_t::ids"]
        [::std::mem::offset_of!(ecs_event_desc_t, ids) - 8usize];
    ["Offset of field: ecs_event_desc_t::table"]
        [::std::mem::offset_of!(ecs_event_desc_t, table) - 16usize];
    ["Offset of field: ecs_event_desc_t::other_table"]
        [::std::mem::offset_of!(ecs_event_desc_t, other_table) - 24usize];
    ["Offset of field: ecs_event_desc_t::offset"]
        [::std::mem::offset_of!(ecs_event_desc_t, offset) - 32usize];
    ["Offset of field: ecs_event_desc_t::count"]
        [::std::mem::offset_of!(ecs_event_desc_t, count) - 36usize];
    ["Offset of field: ecs_event_desc_t::entity"]
        [::std::mem::offset_of!(ecs_event_desc_t, entity) - 40usize];
    ["Offset of field: ecs_event_desc_t::param"]
        [::std::mem::offset_of!(ecs_event_desc_t, param) - 48usize];
    ["Offset of field: ecs_event_desc_t::const_param"]
        [::std::mem::offset_of!(ecs_event_desc_t, const_param) - 56usize];
    ["Offset of field: ecs_event_desc_t::observable"]
        [::std::mem::offset_of!(ecs_event_desc_t, observable) - 64usize];
    ["Offset of field: ecs_event_desc_t::flags"]
        [::std::mem::offset_of!(ecs_event_desc_t, flags) - 72usize];
};
#[doc = " Type with information about the current Flecs build"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_build_info_t {
    #[doc = "< Compiler used to compile flecs"]
    pub compiler: *const ::std::os::raw::c_char,
    #[doc = "< Addons included in build"]
    pub addons: *mut *const ::std::os::raw::c_char,
    #[doc = "< Stringified version"]
    pub version: *const ::std::os::raw::c_char,
    #[doc = "< Major flecs version"]
    pub version_major: i16,
    #[doc = "< Minor flecs version"]
    pub version_minor: i16,
    #[doc = "< Patch flecs version"]
    pub version_patch: i16,
    #[doc = "< Is this a debug build"]
    pub debug: bool,
    #[doc = "< Is this a sanitize build"]
    pub sanitize: bool,
    #[doc = "< Is this a perf tracing build"]
    pub perf_trace: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_build_info_t"][::std::mem::size_of::<ecs_build_info_t>() - 40usize];
    ["Alignment of ecs_build_info_t"][::std::mem::align_of::<ecs_build_info_t>() - 8usize];
    ["Offset of field: ecs_build_info_t::compiler"]
        [::std::mem::offset_of!(ecs_build_info_t, compiler) - 0usize];
    ["Offset of field: ecs_build_info_t::addons"]
        [::std::mem::offset_of!(ecs_build_info_t, addons) - 8usize];
    ["Offset of field: ecs_build_info_t::version"]
        [::std::mem::offset_of!(ecs_build_info_t, version) - 16usize];
    ["Offset of field: ecs_build_info_t::version_major"]
        [::std::mem::offset_of!(ecs_build_info_t, version_major) - 24usize];
    ["Offset of field: ecs_build_info_t::version_minor"]
        [::std::mem::offset_of!(ecs_build_info_t, version_minor) - 26usize];
    ["Offset of field: ecs_build_info_t::version_patch"]
        [::std::mem::offset_of!(ecs_build_info_t, version_patch) - 28usize];
    ["Offset of field: ecs_build_info_t::debug"]
        [::std::mem::offset_of!(ecs_build_info_t, debug) - 30usize];
    ["Offset of field: ecs_build_info_t::sanitize"]
        [::std::mem::offset_of!(ecs_build_info_t, sanitize) - 31usize];
    ["Offset of field: ecs_build_info_t::perf_trace"]
        [::std::mem::offset_of!(ecs_build_info_t, perf_trace) - 32usize];
};
#[doc = " Type that contains information about the world."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_info_t {
    #[doc = "< Last issued component entity id"]
    pub last_component_id: ecs_entity_t,
    #[doc = "< First allowed entity id"]
    pub min_id: ecs_entity_t,
    #[doc = "< Last allowed entity id"]
    pub max_id: ecs_entity_t,
    #[doc = "< Raw delta time (no time scaling)"]
    pub delta_time_raw: f32,
    #[doc = "< Time passed to or computed by ecs_progress()"]
    pub delta_time: f32,
    #[doc = "< Time scale applied to delta_time"]
    pub time_scale: f32,
    #[doc = "< Target fps"]
    pub target_fps: f32,
    #[doc = "< Total time spent processing a frame"]
    pub frame_time_total: f32,
    #[doc = "< Total time spent in systems"]
    pub system_time_total: f32,
    #[doc = "< Total time spent notifying observers"]
    pub emit_time_total: f32,
    #[doc = "< Total time spent in merges"]
    pub merge_time_total: f32,
    #[doc = "< Time spent on query rematching"]
    pub rematch_time_total: f32,
    #[doc = "< Time elapsed in simulation"]
    pub world_time_total: f64,
    #[doc = "< Time elapsed in simulation (no scaling)"]
    pub world_time_total_raw: f64,
    #[doc = "< Total number of frames"]
    pub frame_count_total: i64,
    #[doc = "< Total number of merges"]
    pub merge_count_total: i64,
    #[doc = "< Total number of rematches"]
    pub rematch_count_total: i64,
    #[doc = "< Total number of times a new id was created"]
    pub id_create_total: i64,
    #[doc = "< Total number of times an id was deleted"]
    pub id_delete_total: i64,
    #[doc = "< Total number of times a table was created"]
    pub table_create_total: i64,
    #[doc = "< Total number of times a table was deleted"]
    pub table_delete_total: i64,
    #[doc = "< Total number of pipeline builds"]
    pub pipeline_build_count_total: i64,
    #[doc = "< Total number of systems ran in last frame"]
    pub systems_ran_frame: i64,
    #[doc = "< Total number of times observer was invoked"]
    pub observers_ran_frame: i64,
    #[doc = "< Number of tag (no data) ids in the world"]
    pub tag_id_count: i32,
    #[doc = "< Number of component (data) ids in the world"]
    pub component_id_count: i32,
    #[doc = "< Number of pair ids in the world"]
    pub pair_id_count: i32,
    #[doc = "< Number of tables"]
    pub table_count: i32,
    #[doc = "< Number of tables without entities"]
    pub empty_table_count: i32,
    #[doc = "< Command statistics."]
    pub cmd: ecs_world_info_t__bindgen_ty_1,
    #[doc = "< Value set by ecs_set_name_prefix(). Used\n to remove library prefixes of symbol\n names (such as `Ecs`, `ecs_`) when\n registering them as names."]
    pub name_prefix: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_world_info_t__bindgen_ty_1 {
    #[doc = "< Add commands processed"]
    pub add_count: i64,
    #[doc = "< Remove commands processed"]
    pub remove_count: i64,
    #[doc = "< Selete commands processed"]
    pub delete_count: i64,
    #[doc = "< Clear commands processed"]
    pub clear_count: i64,
    #[doc = "< Set commands processed"]
    pub set_count: i64,
    #[doc = "< Ensure/emplace commands processed"]
    pub ensure_count: i64,
    #[doc = "< Modified commands processed"]
    pub modified_count: i64,
    #[doc = "< Commands discarded, happens when entity is no longer alive when running the command"]
    pub discard_count: i64,
    #[doc = "< Enqueued custom events"]
    pub event_count: i64,
    #[doc = "< Other commands processed"]
    pub other_count: i64,
    #[doc = "< Entities for which commands were batched"]
    pub batched_entity_count: i64,
    #[doc = "< Commands batched"]
    pub batched_command_count: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_info_t__bindgen_ty_1"]
        [::std::mem::size_of::<ecs_world_info_t__bindgen_ty_1>() - 96usize];
    ["Alignment of ecs_world_info_t__bindgen_ty_1"]
        [::std::mem::align_of::<ecs_world_info_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::add_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, add_count) - 0usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::remove_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, remove_count) - 8usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::delete_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, delete_count) - 16usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::clear_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, clear_count) - 24usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::set_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, set_count) - 32usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::ensure_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, ensure_count) - 40usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::modified_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, modified_count) - 48usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::discard_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, discard_count) - 56usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::event_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, event_count) - 64usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::other_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, other_count) - 72usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::batched_entity_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, batched_entity_count) - 80usize];
    ["Offset of field: ecs_world_info_t__bindgen_ty_1::batched_command_count"]
        [::std::mem::offset_of!(ecs_world_info_t__bindgen_ty_1, batched_command_count) - 88usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_world_info_t"][::std::mem::size_of::<ecs_world_info_t>() - 288usize];
    ["Alignment of ecs_world_info_t"][::std::mem::align_of::<ecs_world_info_t>() - 8usize];
    ["Offset of field: ecs_world_info_t::last_component_id"]
        [::std::mem::offset_of!(ecs_world_info_t, last_component_id) - 0usize];
    ["Offset of field: ecs_world_info_t::min_id"]
        [::std::mem::offset_of!(ecs_world_info_t, min_id) - 8usize];
    ["Offset of field: ecs_world_info_t::max_id"]
        [::std::mem::offset_of!(ecs_world_info_t, max_id) - 16usize];
    ["Offset of field: ecs_world_info_t::delta_time_raw"]
        [::std::mem::offset_of!(ecs_world_info_t, delta_time_raw) - 24usize];
    ["Offset of field: ecs_world_info_t::delta_time"]
        [::std::mem::offset_of!(ecs_world_info_t, delta_time) - 28usize];
    ["Offset of field: ecs_world_info_t::time_scale"]
        [::std::mem::offset_of!(ecs_world_info_t, time_scale) - 32usize];
    ["Offset of field: ecs_world_info_t::target_fps"]
        [::std::mem::offset_of!(ecs_world_info_t, target_fps) - 36usize];
    ["Offset of field: ecs_world_info_t::frame_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, frame_time_total) - 40usize];
    ["Offset of field: ecs_world_info_t::system_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, system_time_total) - 44usize];
    ["Offset of field: ecs_world_info_t::emit_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, emit_time_total) - 48usize];
    ["Offset of field: ecs_world_info_t::merge_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, merge_time_total) - 52usize];
    ["Offset of field: ecs_world_info_t::rematch_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, rematch_time_total) - 56usize];
    ["Offset of field: ecs_world_info_t::world_time_total"]
        [::std::mem::offset_of!(ecs_world_info_t, world_time_total) - 64usize];
    ["Offset of field: ecs_world_info_t::world_time_total_raw"]
        [::std::mem::offset_of!(ecs_world_info_t, world_time_total_raw) - 72usize];
    ["Offset of field: ecs_world_info_t::frame_count_total"]
        [::std::mem::offset_of!(ecs_world_info_t, frame_count_total) - 80usize];
    ["Offset of field: ecs_world_info_t::merge_count_total"]
        [::std::mem::offset_of!(ecs_world_info_t, merge_count_total) - 88usize];
    ["Offset of field: ecs_world_info_t::rematch_count_total"]
        [::std::mem::offset_of!(ecs_world_info_t, rematch_count_total) - 96usize];
    ["Offset of field: ecs_world_info_t::id_create_total"]
        [::std::mem::offset_of!(ecs_world_info_t, id_create_total) - 104usize];
    ["Offset of field: ecs_world_info_t::id_delete_total"]
        [::std::mem::offset_of!(ecs_world_info_t, id_delete_total) - 112usize];
    ["Offset of field: ecs_world_info_t::table_create_total"]
        [::std::mem::offset_of!(ecs_world_info_t, table_create_total) - 120usize];
    ["Offset of field: ecs_world_info_t::table_delete_total"]
        [::std::mem::offset_of!(ecs_world_info_t, table_delete_total) - 128usize];
    ["Offset of field: ecs_world_info_t::pipeline_build_count_total"]
        [::std::mem::offset_of!(ecs_world_info_t, pipeline_build_count_total) - 136usize];
    ["Offset of field: ecs_world_info_t::systems_ran_frame"]
        [::std::mem::offset_of!(ecs_world_info_t, systems_ran_frame) - 144usize];
    ["Offset of field: ecs_world_info_t::observers_ran_frame"]
        [::std::mem::offset_of!(ecs_world_info_t, observers_ran_frame) - 152usize];
    ["Offset of field: ecs_world_info_t::tag_id_count"]
        [::std::mem::offset_of!(ecs_world_info_t, tag_id_count) - 160usize];
    ["Offset of field: ecs_world_info_t::component_id_count"]
        [::std::mem::offset_of!(ecs_world_info_t, component_id_count) - 164usize];
    ["Offset of field: ecs_world_info_t::pair_id_count"]
        [::std::mem::offset_of!(ecs_world_info_t, pair_id_count) - 168usize];
    ["Offset of field: ecs_world_info_t::table_count"]
        [::std::mem::offset_of!(ecs_world_info_t, table_count) - 172usize];
    ["Offset of field: ecs_world_info_t::empty_table_count"]
        [::std::mem::offset_of!(ecs_world_info_t, empty_table_count) - 176usize];
    ["Offset of field: ecs_world_info_t::cmd"]
        [::std::mem::offset_of!(ecs_world_info_t, cmd) - 184usize];
    ["Offset of field: ecs_world_info_t::name_prefix"]
        [::std::mem::offset_of!(ecs_world_info_t, name_prefix) - 280usize];
};
#[doc = " Type that contains information about a query group."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_group_info_t {
    #[doc = "< How often tables have been matched/unmatched"]
    pub match_count: i32,
    #[doc = "< Number of tables in group"]
    pub table_count: i32,
    #[doc = "< Group context, returned by on_group_create"]
    pub ctx: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_group_info_t"][::std::mem::size_of::<ecs_query_group_info_t>() - 16usize];
    ["Alignment of ecs_query_group_info_t"]
        [::std::mem::align_of::<ecs_query_group_info_t>() - 8usize];
    ["Offset of field: ecs_query_group_info_t::match_count"]
        [::std::mem::offset_of!(ecs_query_group_info_t, match_count) - 0usize];
    ["Offset of field: ecs_query_group_info_t::table_count"]
        [::std::mem::offset_of!(ecs_query_group_info_t, table_count) - 4usize];
    ["Offset of field: ecs_query_group_info_t::ctx"]
        [::std::mem::offset_of!(ecs_query_group_info_t, ctx) - 8usize];
};
#[doc = " A (string) identifier. Used as pair with #EcsName and #EcsSymbol tags"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsIdentifier {
    #[doc = "< Identifier string"]
    pub value: *mut ::std::os::raw::c_char,
    #[doc = "< Length of identifier"]
    pub length: ecs_size_t,
    #[doc = "< Hash of current value"]
    pub hash: u64,
    #[doc = "< Hash of existing record in current index"]
    pub index_hash: u64,
    #[doc = "< Current index"]
    pub index: *mut ecs_hashmap_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsIdentifier"][::std::mem::size_of::<EcsIdentifier>() - 40usize];
    ["Alignment of EcsIdentifier"][::std::mem::align_of::<EcsIdentifier>() - 8usize];
    ["Offset of field: EcsIdentifier::value"]
        [::std::mem::offset_of!(EcsIdentifier, value) - 0usize];
    ["Offset of field: EcsIdentifier::length"]
        [::std::mem::offset_of!(EcsIdentifier, length) - 8usize];
    ["Offset of field: EcsIdentifier::hash"][::std::mem::offset_of!(EcsIdentifier, hash) - 16usize];
    ["Offset of field: EcsIdentifier::index_hash"]
        [::std::mem::offset_of!(EcsIdentifier, index_hash) - 24usize];
    ["Offset of field: EcsIdentifier::index"]
        [::std::mem::offset_of!(EcsIdentifier, index) - 32usize];
};
#[doc = " Component information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsComponent {
    #[doc = "< Component size"]
    pub size: ecs_size_t,
    #[doc = "< Component alignment"]
    pub alignment: ecs_size_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsComponent"][::std::mem::size_of::<EcsComponent>() - 8usize];
    ["Alignment of EcsComponent"][::std::mem::align_of::<EcsComponent>() - 4usize];
    ["Offset of field: EcsComponent::size"][::std::mem::offset_of!(EcsComponent, size) - 0usize];
    ["Offset of field: EcsComponent::alignment"]
        [::std::mem::offset_of!(EcsComponent, alignment) - 4usize];
};
#[doc = " Component for storing a poly object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsPoly {
    #[doc = "< Pointer to poly object"]
    pub poly: *mut ecs_poly_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsPoly"][::std::mem::size_of::<EcsPoly>() - 8usize];
    ["Alignment of EcsPoly"][::std::mem::align_of::<EcsPoly>() - 8usize];
    ["Offset of field: EcsPoly::poly"][::std::mem::offset_of!(EcsPoly, poly) - 0usize];
};
#[doc = " When added to an entity this informs serialization formats which component\n to use when a value is assigned to an entity without specifying the\n component. This is intended as a hint, serialization formats are not required\n to use it. Adding this component does not change the behavior of core ECS\n operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EcsDefaultChildComponent {
    #[doc = "< Default component id."]
    pub component: ecs_id_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EcsDefaultChildComponent"]
        [::std::mem::size_of::<EcsDefaultChildComponent>() - 8usize];
    ["Alignment of EcsDefaultChildComponent"]
        [::std::mem::align_of::<EcsDefaultChildComponent>() - 8usize];
    ["Offset of field: EcsDefaultChildComponent::component"]
        [::std::mem::offset_of!(EcsDefaultChildComponent, component) - 0usize];
};
extern "C" {
    #[doc = " Indicates that the id is a pair."]
    pub static ECS_PAIR: ecs_id_t;
}
extern "C" {
    #[doc = " Automatically override component when it is inherited"]
    pub static ECS_AUTO_OVERRIDE: ecs_id_t;
}
extern "C" {
    #[doc = " Adds bitset to storage which allows component to be enabled/disabled"]
    pub static ECS_TOGGLE: ecs_id_t;
}
extern "C" {
    #[doc = " Component component id."]
    pub static FLECS_IDEcsComponentID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Identifier component id."]
    pub static FLECS_IDEcsIdentifierID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Poly component id."]
    pub static FLECS_IDEcsPolyID_: ecs_entity_t;
}
extern "C" {
    #[doc = " DefaultChildComponent component id."]
    pub static FLECS_IDEcsDefaultChildComponentID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to queries."]
    pub static EcsQuery: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to observers."]
    pub static EcsObserver: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to systems."]
    pub static EcsSystem: ecs_entity_t;
}
extern "C" {
    #[doc = " TickSource component id."]
    pub static FLECS_IDEcsTickSourceID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Pipeline module component ids"]
    pub static FLECS_IDEcsPipelineQueryID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Timer component id."]
    pub static FLECS_IDEcsTimerID_: ecs_entity_t;
}
extern "C" {
    #[doc = " RateFilter component id."]
    pub static FLECS_IDEcsRateFilterID_: ecs_entity_t;
}
extern "C" {
    #[doc = " Root scope for builtin flecs entities"]
    pub static EcsFlecs: ecs_entity_t;
}
extern "C" {
    #[doc = " Core module scope"]
    pub static EcsFlecsCore: ecs_entity_t;
}
extern "C" {
    #[doc = " Entity associated with world (used for \"attaching\" components to world)"]
    pub static EcsWorld: ecs_entity_t;
}
extern "C" {
    #[doc = " Wildcard entity (\"*\"). Matches any id, returns all matches."]
    pub static EcsWildcard: ecs_entity_t;
}
extern "C" {
    #[doc = " Any entity (\"_\"). Matches any id, returns only the first."]
    pub static EcsAny: ecs_entity_t;
}
extern "C" {
    #[doc = " This entity. Default source for queries."]
    pub static EcsThis: ecs_entity_t;
}
extern "C" {
    #[doc = " Variable entity (\"$\"). Used in expressions to prefix variable names"]
    pub static EcsVariable: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks a relationship as transitive.\n Behavior:\n\n @code\n   if R(X, Y) and R(Y, Z) then R(X, Z)\n @endcode"]
    pub static EcsTransitive: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks a relationship as reflexive.\n Behavior:\n\n @code\n   R(X, X) == true\n @endcode"]
    pub static EcsReflexive: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensures that entity/component cannot be used as target in `IsA` relationship.\n Final can improve the performance of queries as they will not attempt to\n substitute a final component with its subsets.\n\n Behavior:\n\n @code\n   if IsA(X, Y) and Final(Y) throw error\n @endcode"]
    pub static EcsFinal: ecs_entity_t;
}
extern "C" {
    #[doc = " Relationship that specifies component inheritance behavior."]
    pub static EcsOnInstantiate: ecs_entity_t;
}
extern "C" {
    #[doc = " Override component on instantiate.\n This will copy the component from the base entity `(IsA target)` to the\n instance. The base component will never be inherited from the prefab."]
    pub static EcsOverride: ecs_entity_t;
}
extern "C" {
    #[doc = " Inherit component on instantiate.\n This will inherit (share) the component from the base entity `(IsA target)`.\n The component can be manually overridden by adding it to the instance."]
    pub static EcsInherit: ecs_entity_t;
}
extern "C" {
    #[doc = " Never inherit component on instantiate.\n This will not copy or share the component from the base entity `(IsA target)`.\n When the component is added to an instance, its value will never be copied\n from the base entity."]
    pub static EcsDontInherit: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks relationship as commutative.\n Behavior:\n\n @code\n   if R(X, Y) then R(Y, X)\n @endcode"]
    pub static EcsSymmetric: ecs_entity_t;
}
extern "C" {
    #[doc = " Can be added to relationship to indicate that the relationship can only occur\n once on an entity. Adding a 2nd instance will replace the 1st.\n\n Behavior:\n\n @code\n   R(X, Y) + R(X, Z) = R(X, Z)\n @endcode"]
    pub static EcsExclusive: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks a relationship as acyclic. Acyclic relationships may not form cycles."]
    pub static EcsAcyclic: ecs_entity_t;
}
extern "C" {
    #[doc = " Marks a relationship as traversable. Traversable relationships may be\n traversed with \"up\" queries. Traversable relationships are acyclic."]
    pub static EcsTraversable: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure that a component always is added together with another component.\n\n Behavior:\n\n @code\n   If With(R, O) and R(X) then O(X)\n   If With(R, O) and R(X, Y) then O(X, Y)\n @endcode"]
    pub static EcsWith: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure that relationship target is child of specified entity.\n\n Behavior:\n\n @code\n   If OneOf(R, O) and R(X, Y), Y must be a child of O\n   If OneOf(R) and R(X, Y), Y must be a child of R\n @endcode"]
    pub static EcsOneOf: ecs_entity_t;
}
extern "C" {
    #[doc = " Mark a component as toggleable with ecs_enable_id()."]
    pub static EcsCanToggle: ecs_entity_t;
}
extern "C" {
    #[doc = " Can be added to components to indicate it is a trait. Traits are components\n and/or tags that are added to other components to modify their behavior."]
    pub static EcsTrait: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure that an entity is always used in pair as relationship.\n\n Behavior:\n\n @code\n   e.add(R) panics\n   e.add(X, R) panics, unless X has the \"Trait\" trait\n @endcode"]
    pub static EcsRelationship: ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure that an entity is always used in pair as target.\n\n Behavior:\n\n @code\n   e.add(T) panics\n   e.add(T, X) panics\n @endcode"]
    pub static EcsTarget: ecs_entity_t;
}
extern "C" {
    #[doc = " Can be added to relationship to indicate that it should never hold data,\n even when it or the relationship target is a component."]
    pub static EcsPairIsTag: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag to indicate name identifier"]
    pub static EcsName: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag to indicate symbol identifier"]
    pub static EcsSymbol: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag to indicate alias identifier"]
    pub static EcsAlias: ecs_entity_t;
}
extern "C" {
    #[doc = " Used to express parent-child relationships."]
    pub static EcsChildOf: ecs_entity_t;
}
extern "C" {
    #[doc = " Used to express inheritance relationships."]
    pub static EcsIsA: ecs_entity_t;
}
extern "C" {
    #[doc = " Used to express dependency relationships"]
    pub static EcsDependsOn: ecs_entity_t;
}
extern "C" {
    #[doc = " Used to express a slot (used with prefab inheritance)"]
    pub static EcsSlotOf: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to module entities"]
    pub static EcsModule: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag to indicate an entity/component/system is private to a module"]
    pub static EcsPrivate: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag added to prefab entities. Any entity with this tag is automatically\n ignored by queries, unless #EcsPrefab is explicitly queried for."]
    pub static EcsPrefab: ecs_entity_t;
}
extern "C" {
    #[doc = " When this tag is added to an entity it is skipped by queries, unless\n #EcsDisabled is explicitly queried for."]
    pub static EcsDisabled: ecs_entity_t;
}
extern "C" {
    #[doc = " Trait added to entities that should never be returned by queries. Reserved\n for internal entities that have special meaning to the query engine, such as\n #EcsThis, #EcsWildcard, #EcsAny."]
    pub static EcsNotQueryable: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when an id is added to an entity"]
    pub static EcsOnAdd: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when an id is removed from an entity"]
    pub static EcsOnRemove: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a component is set for an entity"]
    pub static EcsOnSet: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers observer when an entity starts/stops matching a query"]
    pub static EcsMonitor: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a table is created."]
    pub static EcsOnTableCreate: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a table is deleted."]
    pub static EcsOnTableDelete: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a table becomes empty (doesn't emit on creation)."]
    pub static EcsOnTableEmpty: ecs_entity_t;
}
extern "C" {
    #[doc = " Event that triggers when a table becomes non-empty."]
    pub static EcsOnTableFill: ecs_entity_t;
}
extern "C" {
    #[doc = " Relationship used for specifying cleanup behavior."]
    pub static EcsOnDelete: ecs_entity_t;
}
extern "C" {
    #[doc = " Relationship used to define what should happen when a target entity (second\n element of a pair) is deleted."]
    pub static EcsOnDeleteTarget: ecs_entity_t;
}
extern "C" {
    #[doc = " Remove cleanup policy. Must be used as target in pair with #EcsOnDelete or\n #EcsOnDeleteTarget."]
    pub static EcsRemove: ecs_entity_t;
}
extern "C" {
    #[doc = " Delete cleanup policy. Must be used as target in pair with #EcsOnDelete or\n #EcsOnDeleteTarget."]
    pub static EcsDelete: ecs_entity_t;
}
extern "C" {
    #[doc = " Panic cleanup policy. Must be used as target in pair with #EcsOnDelete or\n #EcsOnDeleteTarget."]
    pub static EcsPanic: ecs_entity_t;
}
extern "C" {
    #[doc = " Mark component as sparse"]
    pub static EcsSparse: ecs_entity_t;
}
extern "C" {
    #[doc = " Mark relationship as union"]
    pub static EcsUnion: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate `$var == ...` matching in queries."]
    pub static EcsPredEq: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate `$var == \"name\"` matching in queries."]
    pub static EcsPredMatch: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate `$var ~= \"pattern\"` matching in queries."]
    pub static EcsPredLookup: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate the start of a scope (`{`) in queries."]
    pub static EcsScopeOpen: ecs_entity_t;
}
extern "C" {
    #[doc = " Marker used to indicate the end of a scope (`}`) in queries."]
    pub static EcsScopeClose: ecs_entity_t;
}
extern "C" {
    #[doc = " Tag used to indicate query is empty.\n This tag is removed automatically when a query becomes non-empty, and is not\n automatically re-added when it becomes empty."]
    pub static EcsEmpty: ecs_entity_t;
}
extern "C" {
    #[doc = "< Pipeline component id."]
    pub static FLECS_IDEcsPipelineID_: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnStart pipeline phase."]
    pub static EcsOnStart: ecs_entity_t;
}
extern "C" {
    #[doc = "< PreFrame pipeline phase."]
    pub static EcsPreFrame: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnLoad pipeline phase."]
    pub static EcsOnLoad: ecs_entity_t;
}
extern "C" {
    #[doc = "< PostLoad pipeline phase."]
    pub static EcsPostLoad: ecs_entity_t;
}
extern "C" {
    #[doc = "< PreUpdate pipeline phase."]
    pub static EcsPreUpdate: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnUpdate pipeline phase."]
    pub static EcsOnUpdate: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnValidate pipeline phase."]
    pub static EcsOnValidate: ecs_entity_t;
}
extern "C" {
    #[doc = "< PostUpdate pipeline phase."]
    pub static EcsPostUpdate: ecs_entity_t;
}
extern "C" {
    #[doc = "< PreStore pipeline phase."]
    pub static EcsPreStore: ecs_entity_t;
}
extern "C" {
    #[doc = "< OnStore pipeline phase."]
    pub static EcsOnStore: ecs_entity_t;
}
extern "C" {
    #[doc = "< PostFrame pipeline phase."]
    pub static EcsPostFrame: ecs_entity_t;
}
extern "C" {
    #[doc = "< Phase pipeline phase."]
    pub static EcsPhase: ecs_entity_t;
}
extern "C" {
    #[doc = " Create a new world.\n This operation automatically imports modules from addons Flecs has been built\n with, except when the module specifies otherwise.\n\n @return A new world"]
    pub fn ecs_init() -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Create a new world with just the core module.\n Same as ecs_init(), but doesn't import modules from addons. This operation is\n faster than ecs_init() and results in less memory utilization.\n\n @return A new tiny world"]
    pub fn ecs_mini() -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Create a new world with arguments.\n Same as ecs_init(), but allows passing in command line arguments. Command line\n arguments are used to:\n - automatically derive the name of the application from argv[0]\n\n @return A new world"]
    pub fn ecs_init_w_args(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Delete a world.\n This operation deletes the world, and everything it contains.\n\n @param world The world to delete.\n @return Zero if successful, non-zero if failed."]
    pub fn ecs_fini(world: *mut ecs_world_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether the world is being deleted.\n This operation can be used in callbacks like type hooks or observers to\n detect if they are invoked while the world is being deleted.\n\n @param world The world.\n @return True if being deleted, false if not."]
    pub fn ecs_is_fini(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Register action to be executed when world is destroyed.\n Fini actions are typically used when a module needs to clean up before a\n world shuts down.\n\n @param world The world.\n @param action The function to execute.\n @param ctx Userdata to pass to the function"]
    pub fn ecs_atfini(
        world: *mut ecs_world_t,
        action: ecs_fini_action_t,
        ctx: *mut ::std::os::raw::c_void,
    );
}
#[doc = " Type returned by ecs_get_entities()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_entities_t {
    #[doc = "< Array with all entity ids in the world."]
    pub ids: *const ecs_entity_t,
    #[doc = "< Total number of entity ids."]
    pub count: i32,
    #[doc = "< Number of alive entity ids."]
    pub alive_count: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_entities_t"][::std::mem::size_of::<ecs_entities_t>() - 16usize];
    ["Alignment of ecs_entities_t"][::std::mem::align_of::<ecs_entities_t>() - 8usize];
    ["Offset of field: ecs_entities_t::ids"][::std::mem::offset_of!(ecs_entities_t, ids) - 0usize];
    ["Offset of field: ecs_entities_t::count"]
        [::std::mem::offset_of!(ecs_entities_t, count) - 8usize];
    ["Offset of field: ecs_entities_t::alive_count"]
        [::std::mem::offset_of!(ecs_entities_t, alive_count) - 12usize];
};
extern "C" {
    #[doc = " Return entity identifiers in world.\n This operation returns an array with all entity ids that exist in the world.\n Note that the returned array will change and may get invalidated as a result\n of entity creation & deletion.\n\n To iterate all alive entity ids, do:\n @code\n ecs_entities_t entities = ecs_get_entities(world);\n for (int i = 0; i < entities.alive_count; i ++) {\n   ecs_entity_t id = entities.ids[i];\n }\n @endcode\n\n To iterate not-alive ids, do:\n @code\n for (int i = entities.alive_count + 1; i < entities.count; i ++) {\n   ecs_entity_t id = entities.ids[i];\n }\n @endcode\n\n The returned array does not need to be freed. Mutating the returned array\n will return in undefined behavior (and likely crashes).\n\n @param world The world.\n @return Struct with entity id array."]
    pub fn ecs_get_entities(world: *const ecs_world_t) -> ecs_entities_t;
}
extern "C" {
    #[doc = " Begin frame.\n When an application does not use ecs_progress() to control the main loop, it\n can still use Flecs features such as FPS limiting and time measurements. This\n operation needs to be invoked whenever a new frame is about to get processed.\n\n Calls to ecs_frame_begin() must always be followed by ecs_frame_end().\n\n The function accepts a delta_time parameter, which will get passed to\n systems. This value is also used to compute the amount of time the function\n needs to sleep to ensure it does not exceed the target_fps, when it is set.\n When 0 is provided for delta_time, the time will be measured.\n\n This function should only be ran from the main thread.\n\n @param world The world.\n @param delta_time Time elapsed since the last frame.\n @return The provided delta_time, or measured time if 0 was provided."]
    pub fn ecs_frame_begin(world: *mut ecs_world_t, delta_time: f32) -> f32;
}
extern "C" {
    #[doc = " End frame.\n This operation must be called at the end of the frame, and always after\n ecs_frame_begin().\n\n @param world The world."]
    pub fn ecs_frame_end(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Register action to be executed once after frame.\n Post frame actions are typically used for calling operations that cannot be\n invoked during iteration, such as changing the number of threads.\n\n @param world The world.\n @param action The function to execute.\n @param ctx Userdata to pass to the function"]
    pub fn ecs_run_post_frame(
        world: *mut ecs_world_t,
        action: ecs_fini_action_t,
        ctx: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Signal exit\n This operation signals that the application should quit. It will cause\n ecs_progress() to return false.\n\n @param world The world to quit."]
    pub fn ecs_quit(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Return whether a quit has been requested.\n\n @param world The world.\n @return Whether a quit has been requested.\n @see ecs_quit()"]
    pub fn ecs_should_quit(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Measure frame time.\n Frame time measurements measure the total time passed in a single frame, and\n how much of that time was spent on systems and on merging.\n\n Frame time measurements add a small constant-time overhead to an application.\n When an application sets a target FPS, frame time measurements are enabled by\n default.\n\n @param world The world.\n @param enable Whether to enable or disable frame time measuring."]
    pub fn ecs_measure_frame_time(world: *mut ecs_world_t, enable: bool);
}
extern "C" {
    #[doc = " Measure system time.\n System time measurements measure the time spent in each system.\n\n System time measurements add overhead to every system invocation and\n therefore have a small but measurable impact on application performance.\n System time measurements must be enabled before obtaining system statistics.\n\n @param world The world.\n @param enable Whether to enable or disable system time measuring."]
    pub fn ecs_measure_system_time(world: *mut ecs_world_t, enable: bool);
}
extern "C" {
    #[doc = " Set target frames per second (FPS) for application.\n Setting the target FPS ensures that ecs_progress() is not invoked faster than\n the specified FPS. When enabled, ecs_progress() tracks the time passed since\n the last invocation, and sleeps the remaining time of the frame (if any).\n\n This feature ensures systems are ran at a consistent interval, as well as\n conserving CPU time by not running systems more often than required.\n\n Note that ecs_progress() only sleeps if there is time left in the frame. Both\n time spent in flecs as time spent outside of flecs are taken into\n account.\n\n @param world The world.\n @param fps The target FPS."]
    pub fn ecs_set_target_fps(world: *mut ecs_world_t, fps: f32);
}
extern "C" {
    #[doc = " Set default query flags.\n Set a default value for the ecs_filter_desc_t::flags field. Default flags\n are applied in addition to the flags provided in the descriptor. For a\n list of available flags, see include/flecs/private/api_flags.h. Typical flags\n to use are:\n\n  - `EcsQueryMatchEmptyTables`\n  - `EcsQueryMatchDisabled`\n  - `EcsQueryMatchPrefab`\n\n @param world The world.\n @param flags The query flags."]
    pub fn ecs_set_default_query_flags(world: *mut ecs_world_t, flags: ecs_flags32_t);
}
extern "C" {
    #[doc = " Begin readonly mode.\n This operation puts the world in readonly mode, which disallows mutations on\n the world. Readonly mode exists so that internal mechanisms can implement\n optimizations that certain aspects of the world to not change, while also\n providing a mechanism for applications to prevent accidental mutations in,\n for example, multithreaded applications.\n\n Readonly mode is a stronger version of deferred mode. In deferred mode\n ECS operations such as add/remove/set/delete etc. are added to a command\n queue to be executed later. In readonly mode, operations that could break\n scheduler logic (such as creating systems, queries) are also disallowed.\n\n Readonly mode itself has a single threaded and a multi threaded mode. In\n single threaded mode certain mutations on the world are still allowed, for\n example:\n - Entity liveliness operations (such as new, make_alive), so that systems are\n   able to create new entities.\n - Implicit component registration, so that this works from systems\n - Mutations to supporting data structures for the evaluation of uncached\n   queries (filters), so that these can be created on the fly.\n\n These mutations are safe in a single threaded applications, but for\n multithreaded applications the world needs to be entirely immutable. For this\n purpose multi threaded readonly mode exists, which disallows all mutations on\n the world. This means that in multi threaded applications, entity liveliness\n operations, implicit component registration, and on-the-fly query creation\n are not guaranteed to work.\n\n While in readonly mode, applications can still enqueue ECS operations on a\n stage. Stages are managed automatically when using the pipeline addon and\n ecs_progress(), but they can also be configured manually as shown here:\n\n @code\n // Number of stages typically corresponds with number of threads\n ecs_set_stage_count(world, 2);\n ecs_stage_t *stage = ecs_get_stage(world, 1);\n\n ecs_readonly_begin(world);\n ecs_add(world, e, Tag); // readonly assert\n ecs_add(stage, e, Tag); // OK\n @endcode\n\n When an attempt is made to perform an operation on a world in readonly mode,\n the code will throw an assert saying that the world is in readonly mode.\n\n A call to ecs_readonly_begin() must be followed up with ecs_readonly_end().\n When ecs_readonly_end() is called, all enqueued commands from configured\n stages are merged back into the world. Calls to ecs_readonly_begin() and\n ecs_readonly_end() should always happen from a context where the code has\n exclusive access to the world. The functions themselves are not thread safe.\n\n In a typical application, a (non-exhaustive) call stack that uses\n ecs_readonly_begin() and ecs_readonly_end() will look like this:\n\n @code\n ecs_progress()\n   ecs_readonly_begin()\n     ecs_defer_begin()\n\n       // user code\n\n   ecs_readonly_end()\n     ecs_defer_end()\n@endcode\n\n @param world The world\n @param multi_threaded Whether to enable readonly/multi threaded mode.\n @return Whether world is in readonly mode."]
    pub fn ecs_readonly_begin(world: *mut ecs_world_t, multi_threaded: bool) -> bool;
}
extern "C" {
    #[doc = " End readonly mode.\n This operation ends readonly mode, and must be called after\n ecs_readonly_begin(). Operations that were deferred while the world was in\n readonly mode will be flushed.\n\n @param world The world"]
    pub fn ecs_readonly_end(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Merge world or stage.\n When automatic merging is disabled, an application can call this\n operation on either an individual stage, or on the world which will merge\n all stages. This operation may only be called when staging is not enabled\n (either after ecs_progress() or after ecs_readonly_end()).\n\n This operation may be called on an already merged stage or world.\n\n @param world The world."]
    pub fn ecs_merge(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Defer operations until end of frame.\n When this operation is invoked while iterating, operations inbetween the\n ecs_defer_begin() and ecs_defer_end() operations are executed at the end\n of the frame.\n\n This operation is thread safe.\n\n @param world The world.\n @return true if world changed from non-deferred mode to deferred mode.\n\n @see ecs_defer_end()\n @see ecs_is_deferred()\n @see ecs_defer_resume()\n @see ecs_defer_suspend()"]
    pub fn ecs_defer_begin(world: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Test if deferring is enabled for current stage.\n\n @param world The world.\n @return True if deferred, false if not.\n\n @see ecs_defer_begin()\n @see ecs_defer_end()\n @see ecs_defer_resume()\n @see ecs_defer_suspend()"]
    pub fn ecs_is_deferred(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " End block of operations to defer.\n See ecs_defer_begin().\n\n This operation is thread safe.\n\n @param world The world.\n @return true if world changed from deferred mode to non-deferred mode.\n\n @see ecs_defer_begin()\n @see ecs_defer_is_deferred()\n @see ecs_defer_resume()\n @see ecs_defer_suspend()"]
    pub fn ecs_defer_end(world: *mut ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Suspend deferring but do not flush queue.\n This operation can be used to do an undeferred operation while not flushing\n the operations in the queue.\n\n An application should invoke ecs_defer_resume() before ecs_defer_end() is called.\n The operation may only be called when deferring is enabled.\n\n @param world The world.\n\n @see ecs_defer_begin()\n @see ecs_defer_end()\n @see ecs_defer_is_deferred()\n @see ecs_defer_resume()"]
    pub fn ecs_defer_suspend(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Resume deferring.\n See ecs_defer_suspend().\n\n @param world The world.\n\n @see ecs_defer_begin()\n @see ecs_defer_end()\n @see ecs_defer_is_deferred()\n @see ecs_defer_suspend()"]
    pub fn ecs_defer_resume(world: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Configure world to have N stages.\n This initializes N stages, which allows applications to defer operations to\n multiple isolated defer queues. This is typically used for applications with\n multiple threads, where each thread gets its own queue, and commands are\n merged when threads are synchronized.\n\n Note that the ecs_set_threads() function already creates the appropriate\n number of stages. The ecs_set_stage_count() operation is useful for applications\n that want to manage their own stages and/or threads.\n\n @param world The world.\n @param stages The number of stages."]
    pub fn ecs_set_stage_count(world: *mut ecs_world_t, stages: i32);
}
extern "C" {
    #[doc = " Get number of configured stages.\n Return number of stages set by ecs_set_stage_count().\n\n @param world The world.\n @return The number of stages used for threading."]
    pub fn ecs_get_stage_count(world: *const ecs_world_t) -> i32;
}
extern "C" {
    #[doc = " Get stage-specific world pointer.\n Flecs threads can safely invoke the API as long as they have a private\n context to write to, also referred to as the stage. This function returns a\n pointer to a stage, disguised as a world pointer.\n\n Note that this function does not(!) create a new world. It simply wraps the\n existing world in a thread-specific context, which the API knows how to\n unwrap. The reason the stage is returned as an ecs_world_t is so that it\n can be passed transparently to the existing API functions, vs. having to\n create a dedicated API for threading.\n\n @param world The world.\n @param stage_id The index of the stage to retrieve.\n @return A thread-specific pointer to the world."]
    pub fn ecs_get_stage(world: *const ecs_world_t, stage_id: i32) -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Test whether the current world is readonly.\n This function allows the code to test whether the currently used world\n is readonly or whether it allows for writing.\n\n @param world A pointer to a stage or the world.\n @return True if the world or stage is readonly."]
    pub fn ecs_stage_is_readonly(world: *const ecs_world_t) -> bool;
}
extern "C" {
    #[doc = " Create unmanaged stage.\n Create a stage whose lifecycle is not managed by the world. Must be freed\n with ecs_stage_free().\n\n @param world The world.\n @return The stage."]
    pub fn ecs_stage_new(world: *mut ecs_world_t) -> *mut ecs_world_t;
}
extern "C" {
    #[doc = " Free unmanaged stage.\n\n @param stage The stage to free."]
    pub fn ecs_stage_free(stage: *mut ecs_world_t);
}
extern "C" {
    #[doc = " Get stage id.\n The stage id can be used by an application to learn about which stage it is\n using, which typically corresponds with the worker thread id.\n\n @param world The world.\n @return The stage id."]
    pub fn ecs_stage_get_id(world: *const ecs_world_t) -> i32;
}
extern "C" {
    #[doc = " Set a world context.\n This operation allows an application to register custom data with a world\n that can be accessed anywhere where the application has the world.\n\n @param world The world.\n @param ctx A pointer to a user defined structure.\n @param ctx_free A function that is invoked with ctx when the world is freed."]
    pub fn ecs_set_ctx(
        world: *mut ecs_world_t,
        ctx: *mut ::std::os::raw::c_void,
        ctx_free: ecs_ctx_free_t,
    );
}
extern "C" {
    #[doc = " Set a world binding context.\n Same as ecs_set_ctx() but for binding context. A binding context is intended\n specifically for language bindings to store binding specific data.\n\n @param world The world.\n @param ctx A pointer to a user defined structure.\n @param ctx_free A function that is invoked with ctx when the world is freed."]
    pub fn ecs_set_binding_ctx(
        world: *mut ecs_world_t,
        ctx: *mut ::std::os::raw::c_void,
        ctx_free: ecs_ctx_free_t,
    );
}
extern "C" {
    #[doc = " Get the world context.\n This operation retrieves a previously set world context.\n\n @param world The world.\n @return The context set with ecs_set_ctx(). If no context was set, the\n         function returns NULL."]
    pub fn ecs_get_ctx(world: *const ecs_world_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the world binding context.\n This operation retrieves a previously set world binding context.\n\n @param world The world.\n @return The context set with ecs_set_binding_ctx(). If no context was set, the\n         function returns NULL."]
    pub fn ecs_get_binding_ctx(world: *const ecs_world_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get build info.\n  Returns information about the current Flecs build.\n\n @return A struct with information about the current Flecs build."]
    pub fn ecs_get_build_info() -> *const ecs_build_info_t;
}
extern "C" {
    #[doc = " Get world info.\n\n @param world The world.\n @return Pointer to the world info. Valid for as long as the world exists."]
    pub fn ecs_get_world_info(world: *const ecs_world_t) -> *const ecs_world_info_t;
}
extern "C" {
    #[doc = " Dimension the world for a specified number of entities.\n This operation will preallocate memory in the world for the specified number\n of entities. Specifying a number lower than the current number of entities in\n the world will have no effect.\n\n @param world The world.\n @param entity_count The number of entities to preallocate."]
    pub fn ecs_dim(world: *mut ecs_world_t, entity_count: i32);
}
extern "C" {
    #[doc = " Set a range for issuing new entity ids.\n This function constrains the entity identifiers returned by ecs_new_w() to the\n specified range. This operation can be used to ensure that multiple processes\n can run in the same simulation without requiring a central service that\n coordinates issuing identifiers.\n\n If `id_end` is set to 0, the range is infinite. If `id_end` is set to a non-zero\n value, it has to be larger than `id_start`. If `id_end` is set and ecs_new() is\n invoked after an id is issued that is equal to `id_end`, the application will\n abort.\n\n @param world The world.\n @param id_start The start of the range.\n @param id_end The end of the range."]
    pub fn ecs_set_entity_range(
        world: *mut ecs_world_t,
        id_start: ecs_entity_t,
        id_end: ecs_entity_t,
    );
}
extern "C" {
    #[doc = " Enable/disable range limits.\n When an application is both a receiver of range-limited entities and a\n producer of range-limited entities, range checking needs to be temporarily\n disabled when inserting received entities. Range checking is disabled on a\n stage, so setting this value is thread safe.\n\n @param world The world.\n @param enable True if range checking should be enabled, false to disable.\n @return The previous value."]
    pub fn ecs_enable_range_check(world: *mut ecs_world_t, enable: bool) -> bool;
}
extern "C" {
    #[doc = " Get the largest issued entity id (not counting generation).\n\n @param world The world.\n @return The largest issued entity id."]
    pub fn ecs_get_max_id(world: *const ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Force aperiodic actions.\n The world may delay certain operations until they are necessary for the\n application to function correctly. This may cause observable side effects\n such as delayed triggering of events, which can be inconvenient when for\n example running a test suite.\n\n The flags parameter specifies which aperiodic actions to run. Specify 0 to\n run all actions. Supported flags start with 'EcsAperiodic'. Flags identify\n internal mechanisms and may change unannounced.\n\n @param world The world.\n @param flags The flags specifying which actions to run."]
    pub fn ecs_run_aperiodic(world: *mut ecs_world_t, flags: ecs_flags32_t);
}
extern "C" {
    #[doc = " Cleanup empty tables.\n This operation cleans up empty tables that meet certain conditions. Having\n large amounts of empty tables does not negatively impact performance of the\n ECS, but can take up considerable amounts of memory, especially in\n applications with many components, and many components per entity.\n\n The generation specifies the minimum number of times this operation has\n to be called before an empty table is cleaned up. If a table becomes non\n empty, the generation is reset.\n\n The operation allows for both a \"clear\" generation and a \"delete\"\n generation. When the clear generation is reached, the table's\n resources are freed (like component arrays) but the table itself is not\n deleted. When the delete generation is reached, the empty table is deleted.\n\n By specifying a non-zero id the cleanup logic can be limited to tables with\n a specific (component) id. The operation will only increase the generation\n count of matching tables.\n\n The min_id_count specifies a lower bound for the number of components a table\n should have. Often the more components a table has, the more specific it is\n and therefore less likely to be reused.\n\n The time budget specifies how long the operation should take at most.\n\n @param world The world.\n @param id Optional component filter for the tables to evaluate.\n @param clear_generation Free table data when generation > clear_generation.\n @param delete_generation Delete table when generation > delete_generation.\n @param min_id_count Minimum number of component ids the table should have.\n @param time_budget_seconds Amount of time operation is allowed to spend.\n @return Number of deleted tables."]
    pub fn ecs_delete_empty_tables(
        world: *mut ecs_world_t,
        id: ecs_id_t,
        clear_generation: u16,
        delete_generation: u16,
        min_id_count: i32,
        time_budget_seconds: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " Get world from poly.\n\n @param poly A pointer to a poly object.\n @return The world."]
    pub fn ecs_get_world(poly: *const ecs_poly_t) -> *const ecs_world_t;
}
extern "C" {
    #[doc = " Get entity from poly.\n\n @param poly A pointer to a poly object.\n @return Entity associated with the poly object."]
    pub fn ecs_get_entity(poly: *const ecs_poly_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Test if pointer is of specified type.\n Usage:\n\n @code\n flecs_poly_is(ptr, ecs_world_t)\n @endcode\n\n This operation only works for poly types.\n\n @param object The object to test.\n @param type The id of the type.\n @return True if the pointer is of the specified type."]
    pub fn flecs_poly_is_(object: *const ecs_poly_t, type_: i32) -> bool;
}
extern "C" {
    #[doc = " Make a pair id.\n This function is equivalent to using the ecs_pair() macro, and is added for\n convenience to make it easier for non C/C++ bindings to work with pairs.\n\n @param first The first element of the pair of the pair.\n @param second The target of the pair.\n @return A pair id."]
    pub fn ecs_make_pair(first: ecs_entity_t, second: ecs_entity_t) -> ecs_id_t;
}
extern "C" {
    #[doc = " Create new entity id.\n This operation returns an unused entity id. This operation is guaranteed to\n return an empty entity as it does not use values set by ecs_set_scope() or\n ecs_set_with().\n\n @param world The world.\n @return The new entity id."]
    pub fn ecs_new(world: *mut ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Create new low id.\n This operation returns a new low id. Entity ids start after the\n FLECS_HI_COMPONENT_ID constant. This reserves a range of low ids for things\n like components, and allows parts of the code to optimize operations.\n\n Note that FLECS_HI_COMPONENT_ID does not represent the maximum number of\n components that can be created, only the maximum number of components that\n can take advantage of these optimizations.\n\n This operation is guaranteed to return an empty entity as it does not use\n values set by ecs_set_scope() or ecs_set_with().\n\n This operation does not recycle ids.\n\n @param world The world.\n @return The new component id."]
    pub fn ecs_new_low_id(world: *mut ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Create new entity with (component) id.\n This operation creates a new entity with an optional (component) id. When 0\n is passed to the id parameter, no component is added to the new entity.\n\n @param world The world.\n @param id The component id to initialize the new entity with.\n @return The new entity."]
    pub fn ecs_new_w_id(world: *mut ecs_world_t, id: ecs_id_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Create new entity in table.\n This operation creates a new entity in the specified table.\n\n @param world The world.\n @param table The table to which to add the new entity.\n @return The new entity."]
    pub fn ecs_new_w_table(world: *mut ecs_world_t, table: *mut ecs_table_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Find or create an entity.\n This operation creates a new entity, or modifies an existing one. When a name\n is set in the ecs_entity_desc_t::name field and ecs_entity_desc_t::entity is\n not set, the operation will first attempt to find an existing entity by that\n name. If no entity with that name can be found, it will be created.\n\n If both a name and entity handle are provided, the operation will check if\n the entity name matches with the provided name. If the names do not match,\n the function will fail and return 0.\n\n If an id to a non-existing entity is provided, that entity id become alive.\n\n See the documentation of ecs_entity_desc_t for more details.\n\n @param world The world.\n @param desc Entity init parameters.\n @return A handle to the new or existing entity, or 0 if failed."]
    pub fn ecs_entity_init(world: *mut ecs_world_t, desc: *const ecs_entity_desc_t)
        -> ecs_entity_t;
}
extern "C" {
    #[doc = " Bulk create/populate new entities.\n This operation bulk inserts a list of new or predefined entities into a\n single table.\n\n The operation does not take ownership of component arrays provided by the\n application. Components that are non-trivially copyable will be moved into\n the storage.\n\n The operation will emit OnAdd events for each added id, and OnSet events for\n each component that has been set.\n\n If no entity ids are provided by the application, the returned array of ids\n points to an internal data structure which changes when new entities are\n created/deleted.\n\n If as a result of the operation triggers are invoked that deletes\n entities and no entity ids were provided by the application, the returned\n array of identifiers may be incorrect. To avoid this problem, an application\n can first call ecs_bulk_init() to create empty entities, copy the array to one\n that is owned by the application, and then use this array to populate the\n entities.\n\n @param world The world.\n @param desc Bulk creation parameters.\n @return Array with the list of entity ids created/populated."]
    pub fn ecs_bulk_init(
        world: *mut ecs_world_t,
        desc: *const ecs_bulk_desc_t,
    ) -> *const ecs_entity_t;
}
extern "C" {
    #[doc = " Create N new entities.\n This operation is the same as ecs_new_w_id(), but creates N entities\n instead of one.\n\n @param world The world.\n @param id The component id to create the entities with.\n @param count The number of entities to create.\n @return The first entity id of the newly created entities."]
    pub fn ecs_bulk_new_w_id(
        world: *mut ecs_world_t,
        id: ecs_id_t,
        count: i32,
    ) -> *const ecs_entity_t;
}
extern "C" {
    #[doc = " Clone an entity\n This operation clones the components of one entity into another entity. If\n no destination entity is provided, a new entity will be created. Component\n values are not copied unless copy_value is true.\n\n If the source entity has a name, it will not be copied to the destination\n entity. This is to prevent having two entities with the same name under the\n same parent, which is not allowed.\n\n @param world The world.\n @param dst The entity to copy the components to.\n @param src The entity to copy the components from.\n @param copy_value If true, the value of components will be copied to dst.\n @return The destination entity."]
    pub fn ecs_clone(
        world: *mut ecs_world_t,
        dst: ecs_entity_t,
        src: ecs_entity_t,
        copy_value: bool,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Delete an entity.\n This operation will delete an entity and all of its components. The entity id\n will be made available for recycling. If the entity passed to ecs_delete() is\n not alive, the operation will have no side effects.\n\n @param world The world.\n @param entity The entity."]
    pub fn ecs_delete(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Delete all entities with the specified id.\n This will delete all entities (tables) that have the specified id. The id\n may be a wildcard and/or a pair.\n\n @param world The world.\n @param id The id."]
    pub fn ecs_delete_with(world: *mut ecs_world_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Add a (component) id to an entity.\n This operation adds a single (component) id to an entity. If the entity\n already has the id, this operation will have no side effects.\n\n @param world The world.\n @param entity The entity.\n @param id The id to add."]
    pub fn ecs_add_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Remove a (component) id from an entity.\n This operation removes a single (component) id to an entity. If the entity\n does not have the id, this operation will have no side effects.\n\n @param world The world.\n @param entity The entity.\n @param id The id to remove."]
    pub fn ecs_remove_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Add auto override for (component) id.\n An auto override is a component that is automatically added to an entity when\n it is instantiated from a prefab. Auto overrides are added to the entity that\n is inherited from (usually a prefab). For example:\n\n @code\n ecs_entity_t prefab = ecs_insert(world,\n   ecs_value(Position, {10, 20}),\n   ecs_value(Mass, {100}));\n\n ecs_auto_override(world, prefab, Position);\n\n ecs_entity_t inst = ecs_new_w_pair(world, EcsIsA, prefab);\n assert(ecs_owns(world, inst, Position)); // true\n assert(ecs_owns(world, inst, Mass)); // false\n @endcode\n\n An auto override is equivalent to a manual override:\n\n @code\n ecs_entity_t prefab = ecs_insert(world,\n   ecs_value(Position, {10, 20}),\n   ecs_value(Mass, {100}));\n\n ecs_entity_t inst = ecs_new_w_pair(world, EcsIsA, prefab);\n assert(ecs_owns(world, inst, Position)); // false\n ecs_add(world, inst, Position); // manual override\n assert(ecs_owns(world, inst, Position)); // true\n assert(ecs_owns(world, inst, Mass)); // false\n @endcode\n\n This operation is equivalent to manually adding the id with the AUTO_OVERRIDE\n bit applied:\n\n @code\n ecs_add_id(world, entity, ECS_AUTO_OVERRIDE | id);\n @endcode\n\n When a component is overridden and inherited from a prefab, the value from\n the prefab component is copied to the instance. When the component is not\n inherited from a prefab, it is added to the instance as if using ecs_add_id().\n\n Overriding is the default behavior on prefab instantiation. Auto overriding\n is only useful for components with the `(OnInstantiate, Inherit)` trait.\n When a component has the `(OnInstantiate, DontInherit)` trait and is overridden\n the component is added, but the value from the prefab will not be copied.\n\n @param world The world.\n @param entity The entity.\n @param id The (component) id to auto override."]
    pub fn ecs_auto_override_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Clear all components.\n This operation will remove all components from an entity.\n\n @param world The world.\n @param entity The entity."]
    pub fn ecs_clear(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Remove all instances of the specified (component) id.\n This will remove the specified id from all entities (tables). The id may be\n a wildcard and/or a pair.\n\n @param world The world.\n @param id The id."]
    pub fn ecs_remove_all(world: *mut ecs_world_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Set current with id.\n New entities are automatically created with the specified id.\n\n @param world The world.\n @param id The id.\n @return The previous id."]
    pub fn ecs_set_with(world: *mut ecs_world_t, id: ecs_id_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get current with id.\n Get the id set with ecs_set_with().\n\n @param world The world.\n @return The last id provided to ecs_set_with()."]
    pub fn ecs_get_with(world: *const ecs_world_t) -> ecs_id_t;
}
extern "C" {
    #[doc = " Enable or disable entity.\n This operation enables or disables an entity by adding or removing the\n #EcsDisabled tag. A disabled entity will not be matched with any systems,\n unless the system explicitly specifies the #EcsDisabled tag.\n\n @param world The world.\n @param entity The entity to enable or disable.\n @param enabled true to enable the entity, false to disable."]
    pub fn ecs_enable(world: *mut ecs_world_t, entity: ecs_entity_t, enabled: bool);
}
extern "C" {
    #[doc = " Enable or disable component.\n Enabling or disabling a component does not add or remove a component from an\n entity, but prevents it from being matched with queries. This operation can\n be useful when a component must be temporarily disabled without destroying\n its value. It is also a more performant operation for when an application\n needs to add/remove components at high frequency, as enabling/disabling is\n cheaper than a regular add or remove.\n\n @param world The world.\n @param entity The entity.\n @param id The component.\n @param enable True to enable the component, false to disable."]
    pub fn ecs_enable_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t, enable: bool);
}
extern "C" {
    #[doc = " Test if component is enabled.\n Test whether a component is currently enabled or disabled. This operation\n will return true when the entity has the component and if it has not been\n disabled by ecs_enable_component().\n\n @param world The world.\n @param entity The entity.\n @param id The component.\n @return True if the component is enabled, otherwise false."]
    pub fn ecs_is_enabled_id(world: *const ecs_world_t, entity: ecs_entity_t, id: ecs_id_t)
        -> bool;
}
extern "C" {
    #[doc = " Get an immutable pointer to a component.\n This operation obtains a const pointer to the requested component. The\n operation accepts the component entity id.\n\n This operation can return inherited components reachable through an `IsA`\n relationship.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to get.\n @return The component pointer, NULL if the entity does not have the component.\n\n @see ecs_get_mut_id()"]
    pub fn ecs_get_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get a mutable pointer to a component.\n This operation obtains a mutable pointer to the requested component. The\n operation accepts the component entity id.\n\n Unlike ecs_get_id(), this operation does not return inherited components.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to get.\n @return The component pointer, NULL if the entity does not have the component."]
    pub fn ecs_get_mut_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get a mutable pointer to a component.\n This operation returns a mutable pointer to a component. If the component did\n not yet exist, it will be added.\n\n If ensure is called when the world is in deferred/readonly mode, the\n function will:\n - return a pointer to a temp storage if the component does not yet exist, or\n - return a pointer to the existing component if it exists\n\n @param world The world.\n @param entity The entity.\n @param id The entity id of the component to obtain.\n @return The component pointer.\n\n @see ecs_ensure_modified_id()\n @see ecs_emplace_id()"]
    pub fn ecs_ensure_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Combines ensure + modified in single operation.\n This operation is a more efficient alternative to calling ecs_ensure_id() and\n ecs_modified_id() separately. This operation is only valid when the world is in\n deferred mode, which ensures that the Modified event is not emitted before\n the modification takes place.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to obtain.\n @return The component pointer."]
    pub fn ecs_ensure_modified_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Create a component ref.\n A ref is a handle to an entity + component which caches a small amount of\n data to reduce overhead of repeatedly accessing the component. Use\n ecs_ref_get() to get the component data.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component.\n @return The reference."]
    pub fn ecs_ref_init_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
    ) -> ecs_ref_t;
}
extern "C" {
    #[doc = " Get component from ref.\n Get component pointer from ref. The ref must be created with ecs_ref_init().\n\n @param world The world.\n @param ref The ref.\n @param id The component id.\n @return The component pointer, NULL if the entity does not have the component."]
    pub fn ecs_ref_get_id(
        world: *const ecs_world_t,
        ref_: *mut ecs_ref_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Update ref.\n Ensures contents of ref are up to date. Same as ecs_ref_get_id(), but does not\n return pointer to component id.\n\n @param world The world.\n @param ref The ref."]
    pub fn ecs_ref_update(world: *const ecs_world_t, ref_: *mut ecs_ref_t);
}
extern "C" {
    #[doc = " Find record for entity.\n An entity record contains the table and row for the entity.\n\n @param world The world.\n @param entity The entity.\n @return The record, NULL if the entity does not exist."]
    pub fn ecs_record_find(world: *const ecs_world_t, entity: ecs_entity_t) -> *mut ecs_record_t;
}
extern "C" {
    #[doc = " Begin exclusive write access to entity.\n This operation provides safe exclusive access to the components of an entity\n without the overhead of deferring operations.\n\n When this operation is called simultaneously for the same entity more than\n once it will throw an assert. Note that for this to happen, asserts must be\n enabled. It is up to the application to ensure that access is exclusive, for\n example by using a read-write mutex.\n\n Exclusive access is enforced at the table level, so only one entity can be\n exclusively accessed per table. The exclusive access check is thread safe.\n\n This operation must be followed up with ecs_write_end().\n\n @param world The world.\n @param entity The entity.\n @return A record to the entity."]
    pub fn ecs_write_begin(world: *mut ecs_world_t, entity: ecs_entity_t) -> *mut ecs_record_t;
}
extern "C" {
    #[doc = " End exclusive write access to entity.\n This operation ends exclusive access, and must be called after\n ecs_write_begin().\n\n @param record Record to the entity."]
    pub fn ecs_write_end(record: *mut ecs_record_t);
}
extern "C" {
    #[doc = " Begin read access to entity.\n This operation provides safe read access to the components of an entity.\n Multiple simultaneous reads are allowed per entity.\n\n This operation ensures that code attempting to mutate the entity's table will\n throw an assert. Note that for this to happen, asserts must be enabled. It is\n up to the application to ensure that this does not happen, for example by\n using a read-write mutex.\n\n This operation does *not* provide the same guarantees as a read-write mutex,\n as it is possible to call ecs_read_begin() after calling ecs_write_begin(). It is\n up to application has to ensure that this does not happen.\n\n This operation must be followed up with ecs_read_end().\n\n @param world The world.\n @param entity The entity.\n @return A record to the entity."]
    pub fn ecs_read_begin(world: *mut ecs_world_t, entity: ecs_entity_t) -> *const ecs_record_t;
}
extern "C" {
    #[doc = " End read access to entity.\n This operation ends read access, and must be called after ecs_read_begin().\n\n @param record Record to the entity."]
    pub fn ecs_read_end(record: *const ecs_record_t);
}
extern "C" {
    #[doc = " Get entity corresponding with record.\n This operation only works for entities that are not empty.\n\n @param record The record for which to obtain the entity id.\n @return The entity id for the record."]
    pub fn ecs_record_get_entity(record: *const ecs_record_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get component from entity record.\n This operation returns a pointer to a component for the entity\n associated with the provided record. For safe access to the component, obtain\n the record with ecs_read_begin() or ecs_write_begin().\n\n Obtaining a component from a record is faster than obtaining it from the\n entity handle, as it reduces the number of lookups required.\n\n @param world The world.\n @param record Record to the entity.\n @param id The (component) id.\n @return Pointer to component, or NULL if entity does not have the component.\n\n @see ecs_record_ensure_id()"]
    pub fn ecs_record_get_id(
        world: *const ecs_world_t,
        record: *const ecs_record_t,
        id: ecs_id_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Same as ecs_record_get_id(), but returns a mutable pointer.\n For safe access to the component, obtain the record with ecs_write_begin().\n\n @param world The world.\n @param record Record to the entity.\n @param id The (component) id.\n @return Pointer to component, or NULL if entity does not have the component."]
    pub fn ecs_record_ensure_id(
        world: *mut ecs_world_t,
        record: *mut ecs_record_t,
        id: ecs_id_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Test if entity for record has a (component) id.\n\n @param world The world.\n @param record Record to the entity.\n @param id The (component) id.\n @return Whether the entity has the component."]
    pub fn ecs_record_has_id(
        world: *mut ecs_world_t,
        record: *const ecs_record_t,
        id: ecs_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Get component pointer from column/record.\n This returns a pointer to the component using a table column index. The\n table's column index can be found with ecs_table_get_column_index().\n\n Usage:\n @code\n ecs_record_t *r = ecs_record_find(world, entity);\n int32_t column = ecs_table_get_column_index(world, table, ecs_id(Position));\n Position *ptr = ecs_record_get_by_column(r, column, sizeof(Position));\n @endcode\n\n @param record The record.\n @param column The column index in the entity's table.\n @param size The component size.\n @return The component pointer."]
    pub fn ecs_record_get_by_column(
        record: *const ecs_record_t,
        column: i32,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Emplace a component.\n Emplace is similar to ecs_ensure_id() except that the component constructor\n is not invoked for the returned pointer, allowing the component to be\n constructed directly in the storage.\n\n When the `is_new` parameter is not provided, the operation will assert when the\n component already exists. When the `is_new` parameter is provided, it will\n indicate whether the returned storage has been constructed.\n\n When `is_new` indicates that the storage has not yet been constructed, it must\n be constructed by the code invoking this operation. Not constructing the\n component will result in undefined behavior.\n\n @param world The world.\n @param entity The entity.\n @param id The component to obtain.\n @param is_new Whether this is an existing or new component.\n @return The (uninitialized) component pointer."]
    pub fn ecs_emplace_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
        is_new: *mut bool,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Signal that a component has been modified.\n This operation is usually used after modifying a component value obtained by\n ecs_ensure_id(). The operation will mark the component as dirty, and invoke\n OnSet observers and hooks.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component that was modified."]
    pub fn ecs_modified_id(world: *mut ecs_world_t, entity: ecs_entity_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Set the value of a component.\n This operation allows an application to set the value of a component. The\n operation is equivalent to calling ecs_ensure_id() followed by\n ecs_modified_id(). The operation will not modify the value of the passed in\n component. If the component has a copy hook registered, it will be used to\n copy in the component.\n\n If the provided entity is 0, a new entity will be created.\n\n @param world The world.\n @param entity The entity.\n @param id The id of the component to set.\n @param size The size of the pointed-to value.\n @param ptr The pointer to the value."]
    pub fn ecs_set_id(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        id: ecs_id_t,
        size: usize,
        ptr: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Test whether an entity is valid.\n Entities that are valid can be used with API functions. Using invalid\n entities with API operations will cause the function to panic.\n\n An entity is valid if it is not 0 and if it is alive.\n\n ecs_is_valid() will return true for ids that don't exist (alive or not alive). This\n allows for using ids that have never been created by ecs_new_w() or similar. In\n this the function differs from ecs_is_alive(), which will return false for\n entities that do not yet exist.\n\n The operation will return false for an id that exists and is not alive, as\n using this id with an API operation would cause it to assert.\n\n @param world The world.\n @param e The entity.\n @return True if the entity is valid, false if the entity is not valid."]
    pub fn ecs_is_valid(world: *const ecs_world_t, e: ecs_entity_t) -> bool;
}
extern "C" {
    #[doc = " Test whether an entity is alive.\n Entities are alive after they are created, and become not alive when they are\n deleted. Operations that return alive ids are (amongst others) ecs_new(),\n ecs_new_low_id() and ecs_entity_init(). Ids can be made alive with the ecs_make_alive()\n function.\n\n After an id is deleted it can be recycled. Recycled ids are different from\n the original id in that they have a different generation count. This makes it\n possible for the API to distinguish between the two. An example:\n\n @code\n ecs_entity_t e1 = ecs_new(world);\n ecs_is_alive(world, e1);             // true\n ecs_delete(world, e1);\n ecs_is_alive(world, e1);             // false\n\n ecs_entity_t e2 = ecs_new(world);    // recycles e1\n ecs_is_alive(world, e2);             // true\n ecs_is_alive(world, e1);             // false\n @endcode\n\n @param world The world.\n @param e The entity.\n @return True if the entity is alive, false if the entity is not alive."]
    pub fn ecs_is_alive(world: *const ecs_world_t, e: ecs_entity_t) -> bool;
}
extern "C" {
    #[doc = " Remove generation from entity id.\n\n @param e The entity id.\n @return The entity id without the generation count."]
    pub fn ecs_strip_generation(e: ecs_entity_t) -> ecs_id_t;
}
extern "C" {
    #[doc = " Get alive identifier.\n In some cases an application may need to work with identifiers from which\n the generation has been stripped. A typical scenario in which this happens is\n when iterating relationships in an entity type.\n\n For example, when obtaining the parent id from a `ChildOf` relationship, the parent\n (second element of the pair) will have been stored in a 32 bit value, which\n cannot store the entity generation. This function can retrieve the identifier\n with the current generation for that id.\n\n If the provided identifier is not alive, the function will return 0.\n\n @param world The world.\n @param e The for which to obtain the current alive entity id.\n @return The alive entity id if there is one, or 0 if the id is not alive."]
    pub fn ecs_get_alive(world: *const ecs_world_t, e: ecs_entity_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Ensure id is alive.\n This operation ensures that the provided id is alive. This is useful in\n scenarios where an application has an existing id that has not been created\n with ecs_new_w() (such as a global constant or an id from a remote application).\n\n When this operation is successful it guarantees that the provided id exists,\n is valid and is alive.\n\n Before this operation the id must either not be alive or have a generation\n that is equal to the passed in entity.\n\n If the provided id has a non-zero generation count and the id does not exist\n in the world, the id will be created with the specified generation.\n\n If the provided id is alive and has a generation count that does not match\n the provided id, the operation will fail.\n\n @param world The world.\n @param entity The entity id to make alive.\n\n @see ecs_make_alive_id()"]
    pub fn ecs_make_alive(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Same as ecs_make_alive(), but for (component) ids.\n An id can be an entity or pair, and can contain id flags. This operation\n ensures that the entity (or entities, for a pair) are alive.\n\n When this operation is successful it guarantees that the provided id can be\n used in operations that accept an id.\n\n Since entities in a pair do not encode their generation ids, this operation\n will not fail when an entity with non-zero generation count already exists in\n the world.\n\n This is different from ecs_make_alive(), which will fail if attempted with an id\n that has generation 0 and an entity with a non-zero generation is currently\n alive.\n\n @param world The world.\n @param id The id to make alive."]
    pub fn ecs_make_alive_id(world: *mut ecs_world_t, id: ecs_id_t);
}
extern "C" {
    #[doc = " Test whether an entity exists.\n Similar as ecs_is_alive(), but ignores entity generation count.\n\n @param world The world.\n @param entity The entity.\n @return True if the entity exists, false if the entity does not exist."]
    pub fn ecs_exists(world: *const ecs_world_t, entity: ecs_entity_t) -> bool;
}
extern "C" {
    #[doc = " Override the generation of an entity.\n The generation count of an entity is increased each time an entity is deleted\n and is used to test whether an entity id is alive.\n\n This operation overrides the current generation of an entity with the\n specified generation, which can be useful if an entity is externally managed,\n like for external pools, savefiles or netcode.\n\n This operation is similar to ecs_make_alive(), except that it will also\n override the generation of an alive entity.\n\n @param world The world.\n @param entity Entity for which to set the generation with the new generation."]
    pub fn ecs_set_version(world: *mut ecs_world_t, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Get the type of an entity.\n\n @param world The world.\n @param entity The entity.\n @return The type of the entity, NULL if the entity has no components."]
    pub fn ecs_get_type(world: *const ecs_world_t, entity: ecs_entity_t) -> *const ecs_type_t;
}
extern "C" {
    #[doc = " Get the table of an entity.\n\n @param world The world.\n @param entity The entity.\n @return The table of the entity, NULL if the entity has no components/tags."]
    pub fn ecs_get_table(world: *const ecs_world_t, entity: ecs_entity_t) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Convert type to string.\n The result of this operation must be freed with ecs_os_free().\n\n @param world The world.\n @param type The type.\n @return The stringified type."]
    pub fn ecs_type_str(
        world: *const ecs_world_t,
        type_: *const ecs_type_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert table to string.\n Same as `ecs_type_str(world, ecs_table_get_type(table))`. The result of this\n operation must be freed with ecs_os_free().\n\n @param world The world.\n @param table The table.\n @return The stringified table type.\n\n @see ecs_table_get_type()\n @see ecs_type_str()"]
    pub fn ecs_table_str(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert entity to string.\n Same as combining:\n - ecs_get_path(world, entity)\n - ecs_type_str(world, ecs_get_type(world, entity))\n\n The result of this operation must be freed with ecs_os_free().\n\n @param world The world.\n @param entity The entity.\n @return The entity path with stringified type.\n\n @see ecs_get_path()\n @see ecs_type_str()"]
    pub fn ecs_entity_str(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Test if an entity has an id.\n This operation returns true if the entity has or inherits the specified id.\n\n @param world The world.\n @param entity The entity.\n @param id The id to test for.\n @return True if the entity has the id, false if not.\n\n @see ecs_owns_id()"]
    pub fn ecs_has_id(world: *const ecs_world_t, entity: ecs_entity_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Test if an entity owns an id.\n This operation returns true if the entity has the specified id. The operation\n behaves the same as ecs_has_id(), except that it will return false for\n components that are inherited through an `IsA` relationship.\n\n @param world The world.\n @param entity The entity.\n @param id The id to test for.\n @return True if the entity has the id, false if not."]
    pub fn ecs_owns_id(world: *const ecs_world_t, entity: ecs_entity_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Get the target of a relationship.\n This will return a target (second element of a pair) of the entity for the\n specified relationship. The index allows for iterating through the targets,\n if a single entity has multiple targets for the same relationship.\n\n If the index is larger than the total number of instances the entity has for\n the relationship, the operation will return 0.\n\n @param world The world.\n @param entity The entity.\n @param rel The relationship between the entity and the target.\n @param index The index of the relationship instance.\n @return The target for the relationship at the specified index."]
    pub fn ecs_get_target(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        rel: ecs_entity_t,
        index: i32,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get parent (target of `ChildOf` relationship) for entity.\n This operation is the same as calling:\n\n @code\n ecs_get_target(world, entity, EcsChildOf, 0);\n @endcode\n\n @param world The world.\n @param entity The entity.\n @return The parent of the entity, 0 if the entity has no parent.\n\n @see ecs_get_target()"]
    pub fn ecs_get_parent(world: *const ecs_world_t, entity: ecs_entity_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get the target of a relationship for a given id.\n This operation returns the first entity that has the provided id by following\n the specified relationship. If the entity itself has the id then entity will\n be returned. If the id cannot be found on the entity or by following the\n relationship, the operation will return 0.\n\n This operation can be used to lookup, for example, which prefab is providing\n a component by specifying the `IsA` relationship:\n\n @code\n // Is Position provided by the entity or one of its base entities?\n ecs_get_target_for_id(world, entity, EcsIsA, ecs_id(Position))\n @endcode\n\n @param world The world.\n @param entity The entity.\n @param rel The relationship to follow.\n @param id The id to lookup.\n @return The entity for which the target has been found."]
    pub fn ecs_get_target_for_id(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
        rel: ecs_entity_t,
        id: ecs_id_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Return depth for entity in tree for the specified relationship.\n Depth is determined by counting the number of targets encountered while\n traversing up the relationship tree for rel. Only acyclic relationships are\n supported.\n\n @param world The world.\n @param entity The entity.\n @param rel The relationship.\n @return The depth of the entity in the tree."]
    pub fn ecs_get_depth(world: *const ecs_world_t, entity: ecs_entity_t, rel: ecs_entity_t)
        -> i32;
}
extern "C" {
    #[doc = " Count entities that have the specified id.\n Returns the number of entities that have the specified id.\n\n @param world The world.\n @param entity The id to search for.\n @return The number of entities that have the id."]
    pub fn ecs_count_id(world: *const ecs_world_t, entity: ecs_id_t) -> i32;
}
extern "C" {
    #[doc = " Get the name of an entity.\n This will return the name stored in `(EcsIdentifier, EcsName)`.\n\n @param world The world.\n @param entity The entity.\n @return The type of the entity, NULL if the entity has no name.\n\n @see ecs_set_name()"]
    pub fn ecs_get_name(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the symbol of an entity.\n This will return the symbol stored in `(EcsIdentifier, EcsSymbol)`.\n\n @param world The world.\n @param entity The entity.\n @return The type of the entity, NULL if the entity has no name.\n\n @see ecs_set_symbol()"]
    pub fn ecs_get_symbol(
        world: *const ecs_world_t,
        entity: ecs_entity_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set the name of an entity.\n This will set or overwrite the name of an entity. If no entity is provided,\n a new entity will be created.\n\n The name is stored in `(EcsIdentifier, EcsName)`.\n\n @param world The world.\n @param entity The entity.\n @param name The name.\n @return The provided entity, or a new entity if 0 was provided.\n\n @see ecs_get_name()"]
    pub fn ecs_set_name(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set the symbol of an entity.\n This will set or overwrite the symbol of an entity. If no entity is provided,\n a new entity will be created.\n\n The symbol is stored in (EcsIdentifier, EcsSymbol).\n\n @param world The world.\n @param entity The entity.\n @param symbol The symbol.\n @return The provided entity, or a new entity if 0 was provided.\n\n @see ecs_get_symbol()"]
    pub fn ecs_set_symbol(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        symbol: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set alias for entity.\n An entity can be looked up using its alias from the root scope without\n providing the fully qualified name if its parent. An entity can only have\n a single alias.\n\n The symbol is stored in `(EcsIdentifier, EcsAlias)`.\n\n @param world The world.\n @param entity The entity.\n @param alias The alias."]
    pub fn ecs_set_alias(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        alias: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Lookup an entity by it's path.\n This operation is equivalent to calling:\n\n @code\n ecs_lookup_path_w_sep(world, 0, path, \".\", NULL, true);\n @endcode\n\n @param world The world.\n @param path The entity path.\n @return The entity with the specified path, or 0 if no entity was found.\n\n @see ecs_lookup_child()\n @see ecs_lookup_path_w_sep()\n @see ecs_lookup_symbol()"]
    pub fn ecs_lookup(
        world: *const ecs_world_t,
        path: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Lookup a child entity by name.\n Returns an entity that matches the specified name. Only looks for entities in\n the provided parent. If no parent is provided, look in the current scope (\n root if no scope is provided).\n\n @param world The world.\n @param parent The parent for which to lookup the child.\n @param name The entity name.\n @return The entity with the specified name, or 0 if no entity was found.\n\n @see ecs_lookup()\n @see ecs_lookup_path_w_sep()\n @see ecs_lookup_symbol()"]
    pub fn ecs_lookup_child(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        name: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Lookup an entity from a path.\n Lookup an entity from a provided path, relative to the provided parent. The\n operation will use the provided separator to tokenize the path expression. If\n the provided path contains the prefix, the search will start from the root.\n\n If the entity is not found in the provided parent, the operation will\n continue to search in the parent of the parent, until the root is reached. If\n the entity is still not found, the lookup will search in the flecs.core\n scope. If the entity is not found there either, the function returns 0.\n\n @param world The world.\n @param parent The entity from which to resolve the path.\n @param path The path to resolve.\n @param sep The path separator.\n @param prefix The path prefix.\n @param recursive Recursively traverse up the tree until entity is found.\n @return The entity if found, else 0.\n\n @see ecs_lookup()\n @see ecs_lookup_child()\n @see ecs_lookup_symbol()"]
    pub fn ecs_lookup_path_w_sep(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        path: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
        recursive: bool,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Lookup an entity by its symbol name.\n This looks up an entity by symbol stored in `(EcsIdentifier, EcsSymbol)`. The\n operation does not take into account hierarchies.\n\n This operation can be useful to resolve, for example, a type by its C\n identifier, which does not include the Flecs namespacing.\n\n @param world The world.\n @param symbol The symbol.\n @param lookup_as_path If not found as a symbol, lookup as path.\n @param recursive If looking up as path, recursively traverse up the tree.\n @return The entity if found, else 0.\n\n @see ecs_lookup()\n @see ecs_lookup_child()\n @see ecs_lookup_path_w_sep()"]
    pub fn ecs_lookup_symbol(
        world: *const ecs_world_t,
        symbol: *const ::std::os::raw::c_char,
        lookup_as_path: bool,
        recursive: bool,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get a path identifier for an entity.\n This operation creates a path that contains the names of the entities from\n the specified parent to the provided entity, separated by the provided\n separator. If no parent is provided the path will be relative to the root. If\n a prefix is provided, the path will be prefixed by the prefix.\n\n If the parent is equal to the provided child, the operation will return an\n empty string. If a nonzero component is provided, the path will be created by\n looking for parents with that component.\n\n The returned path should be freed by the application.\n\n @param world The world.\n @param parent The entity from which to create the path.\n @param child The entity to which to create the path.\n @param sep The separator to use between path elements.\n @param prefix The initial character to use for root elements.\n @return The relative entity path.\n\n @see ecs_get_path_w_sep_buf()"]
    pub fn ecs_get_path_w_sep(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        child: ecs_entity_t,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write path identifier to buffer.\n Same as ecs_get_path_w_sep(), but writes result to an ecs_strbuf_t.\n\n @param world The world.\n @param parent The entity from which to create the path.\n @param child The entity to which to create the path.\n @param sep The separator to use between path elements.\n @param prefix The initial character to use for root elements.\n @param buf The buffer to write to.\n\n @see ecs_get_path_w_sep()"]
    pub fn ecs_get_path_w_sep_buf(
        world: *const ecs_world_t,
        parent: ecs_entity_t,
        child: ecs_entity_t,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
        buf: *mut ecs_strbuf_t,
    );
}
extern "C" {
    #[doc = " Find or create entity from path.\n This operation will find or create an entity from a path, and will create any\n intermediate entities if required. If the entity already exists, no entities\n will be created.\n\n If the path starts with the prefix, then the entity will be created from the\n root scope.\n\n @param world The world.\n @param parent The entity relative to which the entity should be created.\n @param path The path to create the entity for.\n @param sep The separator used in the path.\n @param prefix The prefix used in the path.\n @return The entity."]
    pub fn ecs_new_from_path_w_sep(
        world: *mut ecs_world_t,
        parent: ecs_entity_t,
        path: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Add specified path to entity.\n This operation is similar to ecs_new_from_path(), but will instead add the path\n to an existing entity.\n\n If an entity already exists for the path, it will be returned instead.\n\n @param world The world.\n @param entity The entity to which to add the path.\n @param parent The entity relative to which the entity should be created.\n @param path The path to create the entity for.\n @param sep The separator used in the path.\n @param prefix The prefix used in the path.\n @return The entity."]
    pub fn ecs_add_path_w_sep(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        parent: ecs_entity_t,
        path: *const ::std::os::raw::c_char,
        sep: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set the current scope.\n This operation sets the scope of the current stage to the provided entity.\n As a result new entities will be created in this scope, and lookups will be\n relative to the provided scope.\n\n It is considered good practice to restore the scope to the old value.\n\n @param world The world.\n @param scope The entity to use as scope.\n @return The previous scope.\n\n @see ecs_get_scope()"]
    pub fn ecs_set_scope(world: *mut ecs_world_t, scope: ecs_entity_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get the current scope.\n Get the scope set by ecs_set_scope(). If no scope is set, this operation will\n return 0.\n\n @param world The world.\n @return The current scope."]
    pub fn ecs_get_scope(world: *const ecs_world_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set a name prefix for newly created entities.\n This is a utility that lets C modules use prefixed names for C types and\n C functions, while using names for the entity names that do not have the\n prefix. The name prefix is currently only used by ECS_COMPONENT.\n\n @param world The world.\n @param prefix The name prefix to use.\n @return The previous prefix."]
    pub fn ecs_set_name_prefix(
        world: *mut ecs_world_t,
        prefix: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Set search path for lookup operations.\n This operation accepts an array of entity ids that will be used as search\n scopes by lookup operations. The operation returns the current search path.\n It is good practice to restore the old search path.\n\n The search path will be evaluated starting from the last element.\n\n The default search path includes flecs.core. When a custom search path is\n provided it overwrites the existing search path. Operations that rely on\n looking up names from flecs.core without providing the namespace may fail if\n the custom search path does not include flecs.core (EcsFlecsCore).\n\n The search path array is not copied into managed memory. The application must\n ensure that the provided array is valid for as long as it is used as the\n search path.\n\n The provided array must be terminated with a 0 element. This enables an\n application to push/pop elements to an existing array without invoking the\n ecs_set_lookup_path() operation again.\n\n @param world The world.\n @param lookup_path 0-terminated array with entity ids for the lookup path.\n @return Current lookup path array.\n\n @see ecs_get_lookup_path()"]
    pub fn ecs_set_lookup_path(
        world: *mut ecs_world_t,
        lookup_path: *const ecs_entity_t,
    ) -> *mut ecs_entity_t;
}
extern "C" {
    #[doc = " Get current lookup path.\n Returns value set by ecs_set_lookup_path().\n\n @param world The world.\n @return The current lookup path."]
    pub fn ecs_get_lookup_path(world: *const ecs_world_t) -> *mut ecs_entity_t;
}
extern "C" {
    #[doc = " Find or create a component.\n This operation creates a new component, or finds an existing one. The find or\n create behavior is the same as ecs_entity_init().\n\n When an existing component is found, the size and alignment are verified with\n the provided values. If the values do not match, the operation will fail.\n\n See the documentation of ecs_component_desc_t for more details.\n\n @param world The world.\n @param desc Component init parameters.\n @return A handle to the new or existing component, or 0 if failed."]
    pub fn ecs_component_init(
        world: *mut ecs_world_t,
        desc: *const ecs_component_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get the type for an id.\n This function returns the type information for an id. The specified id can be\n any valid id. For the rules on how type information is determined based on\n id, see ecs_get_typeid().\n\n @param world The world.\n @param id The id.\n @return The type information of the id."]
    pub fn ecs_get_type_info(world: *const ecs_world_t, id: ecs_id_t) -> *const ecs_type_info_t;
}
extern "C" {
    #[doc = " Register hooks for component.\n Hooks allow for the execution of user code when components are constructed,\n copied, moved, destructed, added, removed or set. Hooks can be assigned as\n as long as a component has not yet been used (added to an entity).\n\n The hooks that are currently set can be accessed with ecs_get_type_info().\n\n @param world The world.\n @param id The component id for which to register the actions\n @param hooks Type that contains the component actions."]
    pub fn ecs_set_hooks_id(
        world: *mut ecs_world_t,
        id: ecs_entity_t,
        hooks: *const ecs_type_hooks_t,
    );
}
extern "C" {
    #[doc = " Get hooks for component.\n\n @param world The world.\n @param id The component id for which to retrieve the hooks.\n @return The hooks for the component, or NULL if not registered."]
    pub fn ecs_get_hooks_id(world: *const ecs_world_t, id: ecs_entity_t)
        -> *const ecs_type_hooks_t;
}
extern "C" {
    #[doc = " Returns whether specified id a tag.\n This operation returns whether the specified type is a tag (a component\n without data/size).\n\n An id is a tag when:\n - it is an entity without the EcsComponent component\n - it has an EcsComponent with size member set to 0\n - it is a pair where both elements are a tag\n - it is a pair where the first element has the #EcsPairIsTag tag\n\n @param world The world.\n @param id The id.\n @return Whether the provided id is a tag."]
    pub fn ecs_id_is_tag(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Returns whether specified id is in use.\n This operation returns whether an id is in use in the world. An id is in use\n if it has been added to one or more tables.\n\n @param world The world.\n @param id The id.\n @return Whether the id is in use."]
    pub fn ecs_id_in_use(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Get the type for an id.\n This operation returns the component id for an id, if the id is associated\n with a type. For a regular component with a non-zero size (an entity with the\n EcsComponent component) the operation will return the entity itself.\n\n For an entity that does not have the EcsComponent component, or with an\n EcsComponent value with size 0, the operation will return 0.\n\n For a pair id the operation will return the type associated with the pair, by\n applying the following queries in order:\n - The first pair element is returned if it is a component\n - 0 is returned if the relationship entity has the Tag property\n - The second pair element is returned if it is a component\n - 0 is returned.\n\n @param world The world.\n @param id The id.\n @return The type id of the id."]
    pub fn ecs_get_typeid(world: *const ecs_world_t, id: ecs_id_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Utility to match an id with a pattern.\n This operation returns true if the provided pattern matches the provided\n id. The pattern may contain a wildcard (or wildcards, when a pair).\n\n @param id The id.\n @param pattern The pattern to compare with.\n @return Whether the id matches the pattern."]
    pub fn ecs_id_match(id: ecs_id_t, pattern: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Utility to check if id is a pair.\n\n @param id The id.\n @return True if id is a pair."]
    pub fn ecs_id_is_pair(id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Utility to check if id is a wildcard.\n\n @param id The id.\n @return True if id is a wildcard or a pair containing a wildcard."]
    pub fn ecs_id_is_wildcard(id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Utility to check if id is valid.\n A valid id is an id that can be added to an entity. Invalid ids are:\n - ids that contain wildcards\n - ids that contain invalid entities\n - ids that are 0 or contain 0 entities\n\n Note that the same rules apply to removing from an entity, with the exception\n of wildcards.\n\n @param world The world.\n @param id The id.\n @return True if the id is valid."]
    pub fn ecs_id_is_valid(world: *const ecs_world_t, id: ecs_id_t) -> bool;
}
extern "C" {
    #[doc = " Get flags associated with id.\n This operation returns the internal flags (see api_flags.h) that are\n associated with the provided id.\n\n @param world The world.\n @param id The id.\n @return Flags associated with the id, or 0 if the id is not in use."]
    pub fn ecs_id_get_flags(world: *const ecs_world_t, id: ecs_id_t) -> ecs_flags32_t;
}
extern "C" {
    #[doc = " Convert id flag to string.\n This operation converts an id flag to a string.\n\n @param id_flags The id flag.\n @return The id flag string, or NULL if no valid id is provided."]
    pub fn ecs_id_flag_str(id_flags: ecs_id_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert id to string.\n This operation interprets the structure of an id and converts it to a string.\n\n @param world The world.\n @param id The id to convert to a string.\n @return The id converted to a string."]
    pub fn ecs_id_str(world: *const ecs_world_t, id: ecs_id_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Write id string to buffer.\n Same as ecs_id_str() but writes result to ecs_strbuf_t.\n\n @param world The world.\n @param id The id to convert to a string.\n @param buf The buffer to write to."]
    pub fn ecs_id_str_buf(world: *const ecs_world_t, id: ecs_id_t, buf: *mut ecs_strbuf_t);
}
extern "C" {
    #[doc = " Test whether term id is set.\n\n @param id The term id.\n @return True when set, false when not set."]
    pub fn ecs_term_ref_is_set(id: *const ecs_term_ref_t) -> bool;
}
extern "C" {
    #[doc = " Test whether a term is set.\n This operation can be used to test whether a term has been initialized with\n values or whether it is empty.\n\n An application generally does not need to invoke this operation. It is useful\n when initializing a 0-initialized array of terms (like in ecs_term_desc_t) as\n this operation can be used to find the last initialized element.\n\n @param term The term.\n @return True when set, false when not set."]
    pub fn ecs_term_is_initialized(term: *const ecs_term_t) -> bool;
}
extern "C" {
    #[doc = " Is term matched on $this variable.\n This operation checks whether a term is matched on the $this variable, which\n is the default source for queries.\n\n A term has a $this source when:\n - ecs_term_t::src::id is EcsThis\n - ecs_term_t::src::flags is EcsIsVariable\n\n If ecs_term_t::src is not populated, it will be automatically initialized to\n the $this source for the created query.\n\n @param term The term.\n @return True if term matches $this, false if not."]
    pub fn ecs_term_match_this(term: *const ecs_term_t) -> bool;
}
extern "C" {
    #[doc = " Is term matched on 0 source.\n This operation checks whether a term is matched on a 0 source. A 0 source is\n a term that isn't matched against anything, and can be used just to pass\n (component) ids to a query iterator.\n\n A term has a 0 source when:\n - ecs_term_t::src::id is 0\n - ecs_term_t::src::flags has EcsIsEntity set\n\n @param term The term.\n @return True if term has 0 source, false if not."]
    pub fn ecs_term_match_0(term: *const ecs_term_t) -> bool;
}
extern "C" {
    #[doc = " Convert term to string expression.\n Convert term to a string expression. The resulting expression is equivalent\n to the same term, with the exception of And & Or operators.\n\n @param world The world.\n @param term The term.\n @return The term converted to a string."]
    pub fn ecs_term_str(
        world: *const ecs_world_t,
        term: *const ecs_term_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert query to string expression.\n Convert query to a string expression. The resulting expression can be\n parsed to create the same query.\n\n @param query The query.\n @return The query converted to a string."]
    pub fn ecs_query_str(query: *const ecs_query_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Iterate all entities with specified (component id).\n This returns an iterator that yields all entities with a single specified\n component. This is a much lighter weight operation than creating and\n iterating a query.\n\n Usage:\n @code\n ecs_iter_t it = ecs_each(world, Player);\n while (ecs_each_next(&it)) {\n   for (int i = 0; i < it.count; i ++) {\n     // Iterate as usual.\n   }\n }\n @endcode\n\n If the specified id is a component, it is possible to access the component\n pointer with ecs_field just like with regular queries:\n\n @code\n ecs_iter_t it = ecs_each(world, Position);\n while (ecs_each_next(&it)) {\n   Position *p = ecs_field(&it, Position, 0);\n   for (int i = 0; i < it.count; i ++) {\n     // Iterate as usual.\n   }\n }\n @endcode\n\n @param world The world.\n @param id The (component) id to iterate.\n @return An iterator that iterates all entities with the (component) id."]
    pub fn ecs_each_id(world: *const ecs_world_t, id: ecs_id_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress an iterator created with ecs_each_id().\n\n @param it The iterator.\n @return True if the iterator has more results, false if not."]
    pub fn ecs_each_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Iterate children of parent.\n Equivalent to:\n @code\n ecs_iter_t it = ecs_each_id(world, ecs_pair(EcsChildOf, parent));\n @endcode\n\n @param world The world.\n @param parent The parent.\n @return An iterator that iterates all children of the parent.\n\n @see ecs_each_id()"]
    pub fn ecs_children(world: *const ecs_world_t, parent: ecs_entity_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress an iterator created with ecs_children().\n\n @param it The iterator.\n @return True if the iterator has more results, false if not."]
    pub fn ecs_children_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Create a query.\n\n @param world The world.\n @param desc The descriptor (see ecs_query_desc_t)\n @return The query."]
    pub fn ecs_query_init(
        world: *mut ecs_world_t,
        desc: *const ecs_query_desc_t,
    ) -> *mut ecs_query_t;
}
extern "C" {
    #[doc = " Delete a query.\n\n @param query The query."]
    pub fn ecs_query_fini(query: *mut ecs_query_t);
}
extern "C" {
    #[doc = " Find variable index.\n This operation looks up the index of a variable in the query. This index can\n be used in operations like ecs_iter_set_var() and ecs_iter_get_var().\n\n @param query The query.\n @param name The variable name.\n @return The variable index."]
    pub fn ecs_query_find_var(
        query: *const ecs_query_t,
        name: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Get variable name.\n This operation returns the variable name for an index.\n\n @param query The query.\n @param var_id The variable index.\n @return The variable name."]
    pub fn ecs_query_var_name(
        query: *const ecs_query_t,
        var_id: i32,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Test if variable is an entity.\n Internally the query engine has entity variables and table variables. When\n iterating through query variables (by using ecs_query_variable_count()) only\n the values for entity variables are accessible. This operation enables an\n application to check if a variable is an entity variable.\n\n @param query The query.\n @param var_id The variable id.\n @return Whether the variable is an entity variable."]
    pub fn ecs_query_var_is_entity(query: *const ecs_query_t, var_id: i32) -> bool;
}
extern "C" {
    #[doc = " Create a query iterator.\n Use an iterator to iterate through the entities that match an entity. Queries\n can return multiple results, and have to be iterated by repeatedly calling\n ecs_query_next() until the operation returns false.\n\n Depending on the query, a single result can contain an entire table, a range\n of entities in a table, or a single entity. Iteration code has an inner and\n an outer loop. The outer loop loops through the query results, and typically\n corresponds with a table. The inner loop loops entities in the result.\n\n Example:\n @code\n ecs_iter_t it = ecs_query_iter(world, q);\n\n while (ecs_query_next(&it)) {\n   Position *p = ecs_field(&it, Position, 0);\n   Velocity *v = ecs_field(&it, Velocity, 1);\n\n   for (int i = 0; i < it.count; i ++) {\n     p[i].x += v[i].x;\n     p[i].y += v[i].y;\n   }\n }\n @endcode\n\n The world passed into the operation must be either the actual world or the\n current stage, when iterating from a system. The stage is accessible through\n the it.world member.\n\n Example:\n @code\n void MySystem(ecs_iter_t *it) {\n   ecs_query_t *q = it->ctx; // Query passed as system context\n\n   // Create query iterator from system stage\n   ecs_iter_t qit = ecs_query_iter(it->world, q);\n   while (ecs_query_next(&qit)) {\n     // Iterate as usual\n   }\n }\n @endcode\n\n If query iteration is stopped without the last call to ecs_query_next()\n returning false, iterator resources need to be cleaned up explicitly\n with ecs_iter_fini().\n\n Example:\n @code\n ecs_iter_t it = ecs_query_iter(world, q);\n\n while (ecs_query_next(&it)) {\n   if (!ecs_field_is_set(&it, 0)) {\n     ecs_iter_fini(&it); // Free iterator resources\n     break;\n   }\n\n   for (int i = 0; i < it.count; i ++) {\n     // ...\n   }\n }\n @endcode\n\n @param world The world.\n @param query The query.\n @return An iterator.\n\n @see ecs_query_next()"]
    pub fn ecs_query_iter(world: *const ecs_world_t, query: *const ecs_query_t) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress query iterator.\n\n @param it The iterator.\n @return True if the iterator has more results, false if not.\n\n @see ecs_query_iter()"]
    pub fn ecs_query_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Match entity with query.\n This operation matches an entity with a query and returns the result of the\n match in the \"it\" out parameter. An application should free the iterator\n resources with ecs_iter_fini() if this function returns true.\n\n Usage:\n @code\n ecs_iter_t it;\n if (ecs_query_has(q, e, &it)) {\n   ecs_iter_fini(&it);\n }\n @endcode\n\n @param query The query.\n @param entity The entity to match\n @param it The iterator with matched data.\n @return True if entity matches the query, false if not."]
    pub fn ecs_query_has(
        query: *mut ecs_query_t,
        entity: ecs_entity_t,
        it: *mut ecs_iter_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Match table with query.\n This operation matches a table with a query and returns the result of the\n match in the \"it\" out parameter. An application should free the iterator\n resources with ecs_iter_fini() if this function returns true.\n\n Usage:\n @code\n ecs_iter_t it;\n if (ecs_query_has_table(q, t, &it)) {\n   ecs_iter_fini(&it);\n }\n @endcode\n\n @param query The query.\n @param table The table to match\n @param it The iterator with matched data.\n @return True if table matches the query, false if not."]
    pub fn ecs_query_has_table(
        query: *mut ecs_query_t,
        table: *mut ecs_table_t,
        it: *mut ecs_iter_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Match range with query.\n This operation matches a range with a query and returns the result of the\n match in the \"it\" out parameter. An application should free the iterator\n resources with ecs_iter_fini() if this function returns true.\n\n The entire range must match the query for the operation to return true.\n\n Usage:\n @code\n ecs_table_range_t range = {\n   .table = table,\n   .offset = 1,\n   .count = 2\n };\n\n ecs_iter_t it;\n if (ecs_query_has_range(q, &range, &it)) {\n   ecs_iter_fini(&it);\n }\n @endcode\n\n @param query The query.\n @param range The range to match\n @param it The iterator with matched data.\n @return True if range matches the query, false if not."]
    pub fn ecs_query_has_range(
        query: *mut ecs_query_t,
        range: *mut ecs_table_range_t,
        it: *mut ecs_iter_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns how often a match event happened for a cached query.\n This operation can be used to determine whether the query cache has been\n updated with new tables.\n\n @param query The query.\n @return The number of match events happened."]
    pub fn ecs_query_match_count(query: *const ecs_query_t) -> i32;
}
extern "C" {
    #[doc = " Convert query to a string.\n This will convert the query program to a string which can aid in debugging\n the behavior of a query.\n\n The returned string must be freed with ecs_os_free().\n\n @param query The query.\n @return The query plan."]
    pub fn ecs_query_plan(query: *const ecs_query_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert query to string with profile.\n To use this you must set the EcsIterProfile flag on an iterator before\n starting iteration:\n\n @code\n   it.flags |= EcsIterProfile\n @endcode\n\n The returned string must be freed with ecs_os_free().\n\n @param query The query.\n @param it The iterator with profile data.\n @return The query plan with profile data."]
    pub fn ecs_query_plan_w_profile(
        query: *const ecs_query_t,
        it: *const ecs_iter_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Populate variables from key-value string.\n Convenience function to set query variables from a key-value string separated\n by comma's. The string must have the following format:\n\n @code\n   var_a: value, var_b: value\n @endcode\n\n The key-value list may optionally be enclosed in parenthesis.\n\n This function uses the script addon.\n\n @param query The query.\n @param it The iterator for which to set the variables.\n @param expr The key-value expression.\n @return Pointer to the next character after the last parsed one."]
    pub fn ecs_query_args_parse(
        query: *mut ecs_query_t,
        it: *mut ecs_iter_t,
        expr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns whether the query data changed since the last iteration.\n The operation will return true after:\n - new entities have been matched with\n - new tables have been matched/unmatched with\n - matched entities were deleted\n - matched components were changed\n\n The operation will not return true after a write-only (EcsOut) or filter\n (EcsInOutNone) term has changed, when a term is not matched with the\n current table (This subject) or for tag terms.\n\n The changed state of a table is reset after it is iterated. If an iterator was\n not iterated until completion, tables may still be marked as changed.\n\n If no iterator is provided the operation will return the changed state of the\n all matched tables of the query.\n\n If an iterator is provided, the operation will return the changed state of\n the currently returned iterator result. The following preconditions must be\n met before using an iterator with change detection:\n\n - The iterator is a query iterator (created with ecs_query_iter())\n - The iterator must be valid (ecs_query_next() must have returned true)\n\n @param query The query (optional if 'it' is provided).\n @return true if entities changed, otherwise false."]
    pub fn ecs_query_changed(query: *mut ecs_query_t) -> bool;
}
extern "C" {
    #[doc = " Skip a table while iterating.\n This operation lets the query iterator know that a table was skipped while\n iterating. A skipped table will not reset its changed state, and the query\n will not update the dirty flags of the table for its out columns.\n\n Only valid iterators must be provided (next has to be called at least once &\n return true) and the iterator must be a query iterator.\n\n @param it The iterator result to skip."]
    pub fn ecs_iter_skip(it: *mut ecs_iter_t);
}
extern "C" {
    #[doc = " Set group to iterate for query iterator.\n This operation limits the results returned by the query to only the selected\n group id. The query must have a group_by function, and the iterator must\n be a query iterator.\n\n Groups are sets of tables that are stored together in the query cache based\n on a group id, which is calculated per table by the group_by function. To\n iterate a group, an iterator only needs to know the first and last cache node\n for that group, which can both be found in a fast O(1) operation.\n\n As a result, group iteration is one of the most efficient mechanisms to\n filter out large numbers of entities, even if those entities are distributed\n across many tables. This makes it a good fit for things like dividing up\n a world into cells, and only iterating cells close to a player.\n\n The group to iterate must be set before the first call to ecs_query_next(). No\n operations that can add/remove components should be invoked between calling\n ecs_iter_set_group() and ecs_query_next().\n\n @param it The query iterator.\n @param group_id The group to iterate."]
    pub fn ecs_iter_set_group(it: *mut ecs_iter_t, group_id: u64);
}
extern "C" {
    #[doc = " Get context of query group.\n This operation returns the context of a query group as returned by the\n on_group_create callback.\n\n @param query The query.\n @param group_id The group for which to obtain the context.\n @return The group context, NULL if the group doesn't exist."]
    pub fn ecs_query_get_group_ctx(
        query: *const ecs_query_t,
        group_id: u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get information about query group.\n This operation returns information about a query group, including the group\n context returned by the on_group_create callback.\n\n @param query The query.\n @param group_id The group for which to obtain the group info.\n @return The group info, NULL if the group doesn't exist."]
    pub fn ecs_query_get_group_info(
        query: *const ecs_query_t,
        group_id: u64,
    ) -> *const ecs_query_group_info_t;
}
#[doc = " Struct returned by ecs_query_count()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_count_t {
    #[doc = "< Number of results returned by query."]
    pub results: i32,
    #[doc = "< Number of entities returned by query."]
    pub entities: i32,
    #[doc = "< Number of tables returned by query."]
    pub tables: i32,
    #[doc = "< Number of empty tables returned by query."]
    pub empty_tables: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ecs_query_count_t"][::std::mem::size_of::<ecs_query_count_t>() - 16usize];
    ["Alignment of ecs_query_count_t"][::std::mem::align_of::<ecs_query_count_t>() - 4usize];
    ["Offset of field: ecs_query_count_t::results"]
        [::std::mem::offset_of!(ecs_query_count_t, results) - 0usize];
    ["Offset of field: ecs_query_count_t::entities"]
        [::std::mem::offset_of!(ecs_query_count_t, entities) - 4usize];
    ["Offset of field: ecs_query_count_t::tables"]
        [::std::mem::offset_of!(ecs_query_count_t, tables) - 8usize];
    ["Offset of field: ecs_query_count_t::empty_tables"]
        [::std::mem::offset_of!(ecs_query_count_t, empty_tables) - 12usize];
};
extern "C" {
    #[doc = " Returns number of entities and results the query matches with.\n Only entities matching the $this variable as source are counted.\n\n @param query The query.\n @return The number of matched entities."]
    pub fn ecs_query_count(query: *const ecs_query_t) -> ecs_query_count_t;
}
extern "C" {
    #[doc = " Does query return one or more results.\n\n @param query The query.\n @return True if query matches anything, false if not."]
    pub fn ecs_query_is_true(query: *const ecs_query_t) -> bool;
}
extern "C" {
    #[doc = " Send event.\n This sends an event to matching triggers & is the mechanism used by flecs\n itself to send `OnAdd`, `OnRemove`, etc events.\n\n Applications can use this function to send custom events, where a custom\n event can be any regular entity.\n\n Applications should not send builtin flecs events, as this may violate\n assumptions the code makes about the conditions under which those events are\n sent.\n\n Triggers are invoked synchronously. It is therefore safe to use stack-based\n data as event context, which can be set in the \"param\" member.\n\n @param world The world.\n @param desc Event parameters.\n\n @see ecs_enqueue()"]
    pub fn ecs_emit(world: *mut ecs_world_t, desc: *mut ecs_event_desc_t);
}
extern "C" {
    #[doc = " Enqueue event.\n Same as ecs_emit(), but enqueues an event in the command queue instead. The\n event will be emitted when ecs_defer_end() is called.\n\n If this operation is called when the provided world is not in deferred mode\n it behaves just like ecs_emit().\n\n @param world The world.\n @param desc Event parameters."]
    pub fn ecs_enqueue(world: *mut ecs_world_t, desc: *mut ecs_event_desc_t);
}
extern "C" {
    #[doc = " Create observer.\n Observers are like triggers, but can subscribe for multiple terms. An\n observer only triggers when the source of the event meets all terms.\n\n See the documentation for ecs_observer_desc_t for more details.\n\n @param world The world.\n @param desc The observer creation parameters.\n @return The observer, or 0 if the operation failed."]
    pub fn ecs_observer_init(
        world: *mut ecs_world_t,
        desc: *const ecs_observer_desc_t,
    ) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get observer object.\n Returns the observer object. Can be used to access various information about\n the observer, like the query and context.\n\n @param world The world.\n @param observer The observer.\n @return The observer object."]
    pub fn ecs_observer_get(
        world: *const ecs_world_t,
        observer: ecs_entity_t,
    ) -> *const ecs_observer_t;
}
extern "C" {
    #[doc = " Progress any iterator.\n This operation is useful in combination with iterators for which it is not\n known what created them. Example use cases are functions that should accept\n any kind of iterator (such as serializers) or iterators created from poly\n objects.\n\n This operation is slightly slower than using a type-specific iterator (e.g.\n ecs_query_next, ecs_query_next) as it has to call a function pointer which\n introduces a level of indirection.\n\n @param it The iterator.\n @return True if iterator has more results, false if not."]
    pub fn ecs_iter_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Cleanup iterator resources.\n This operation cleans up any resources associated with the iterator.\n\n This operation should only be used when an iterator is not iterated until\n completion (next has not yet returned false). When an iterator is iterated\n until completion, resources are automatically freed.\n\n @param it The iterator."]
    pub fn ecs_iter_fini(it: *mut ecs_iter_t);
}
extern "C" {
    #[doc = " Count number of matched entities in query.\n This operation returns the number of matched entities. If a query contains no\n matched entities but still yields results (e.g. it has no terms with This\n sources) the operation will return 0.\n\n To determine the number of matched entities, the operation iterates the\n iterator until it yields no more results.\n\n @param it The iterator.\n @return True if iterator has more results, false if not."]
    pub fn ecs_iter_count(it: *mut ecs_iter_t) -> i32;
}
extern "C" {
    #[doc = " Test if iterator is true.\n This operation will return true if the iterator returns at least one result.\n This is especially useful in combination with fact-checking queries (see the\n queries addon).\n\n The operation requires a valid iterator. After the operation is invoked, the\n application should no longer invoke next on the iterator and should treat it\n as if the iterator is iterated until completion.\n\n @param it The iterator.\n @return true if the iterator returns at least one result."]
    pub fn ecs_iter_is_true(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Get first matching entity from iterator.\n After this operation the application should treat the iterator as if it has\n been iterated until completion.\n\n @param it The iterator.\n @return The first matching entity, or 0 if no entities were matched."]
    pub fn ecs_iter_first(it: *mut ecs_iter_t) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Set value for iterator variable.\n This constrains the iterator to return only results for which the variable\n equals the specified value. The default value for all variables is\n EcsWildcard, which means the variable can assume any value.\n\n Example:\n\n @code\n // Query that matches (Eats, *)\n ecs_query_t *q = ecs_query(world, {\n   .terms = {\n     { .first.id = Eats, .second.name = \"$food\" }\n   }\n });\n\n int food_var = ecs_query_find_var(r, \"food\");\n\n // Set Food to Apples, so we're only matching (Eats, Apples)\n ecs_iter_t it = ecs_query_iter(world, q);\n ecs_iter_set_var(&it, food_var, Apples);\n\n while (ecs_query_next(&it)) {\n   for (int i = 0; i < it.count; i ++) {\n     // iterate as usual\n   }\n }\n @endcode\n\n The variable must be initialized after creating the iterator and before the\n first call to next.\n\n @param it The iterator.\n @param var_id The variable index.\n @param entity The entity variable value.\n\n @see ecs_iter_set_var_as_range()\n @see ecs_iter_set_var_as_table()"]
    pub fn ecs_iter_set_var(it: *mut ecs_iter_t, var_id: i32, entity: ecs_entity_t);
}
extern "C" {
    #[doc = " Same as ecs_iter_set_var(), but for a table.\n This constrains the variable to all entities in a table.\n\n @param it The iterator.\n @param var_id The variable index.\n @param table The table variable value.\n\n @see ecs_iter_set_var()\n @see ecs_iter_set_var_as_range()"]
    pub fn ecs_iter_set_var_as_table(it: *mut ecs_iter_t, var_id: i32, table: *const ecs_table_t);
}
extern "C" {
    #[doc = " Same as ecs_iter_set_var(), but for a range of entities\n This constrains the variable to a range of entities in a table.\n\n @param it The iterator.\n @param var_id The variable index.\n @param range The range variable value.\n\n @see ecs_iter_set_var()\n @see ecs_iter_set_var_as_table()"]
    pub fn ecs_iter_set_var_as_range(
        it: *mut ecs_iter_t,
        var_id: i32,
        range: *const ecs_table_range_t,
    );
}
extern "C" {
    #[doc = " Get value of iterator variable as entity.\n A variable can be interpreted as entity if it is set to an entity, or if it\n is set to a table range with count 1.\n\n This operation can only be invoked on valid iterators. The variable index\n must be smaller than the total number of variables provided by the iterator\n (as set in ecs_iter_t::variable_count).\n\n @param it The iterator.\n @param var_id The variable index.\n @return The variable value."]
    pub fn ecs_iter_get_var(it: *mut ecs_iter_t, var_id: i32) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Get value of iterator variable as table.\n A variable can be interpreted as table if it is set as table range with\n both offset and count set to 0, or if offset is 0 and count matches the\n number of elements in the table.\n\n This operation can only be invoked on valid iterators. The variable index\n must be smaller than the total number of variables provided by the iterator\n (as set in ecs_iter_t::variable_count).\n\n @param it The iterator.\n @param var_id The variable index.\n @return The variable value."]
    pub fn ecs_iter_get_var_as_table(it: *mut ecs_iter_t, var_id: i32) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Get value of iterator variable as table range.\n A value can be interpreted as table range if it is set as table range, or if\n it is set to an entity with a non-empty type (the entity must have at least\n one component, tag or relationship in its type).\n\n This operation can only be invoked on valid iterators. The variable index\n must be smaller than the total number of variables provided by the iterator\n (as set in ecs_iter_t::variable_count).\n\n @param it The iterator.\n @param var_id The variable index.\n @return The variable value."]
    pub fn ecs_iter_get_var_as_range(it: *mut ecs_iter_t, var_id: i32) -> ecs_table_range_t;
}
extern "C" {
    #[doc = " Returns whether variable is constrained.\n This operation returns true for variables set by one of the ecs_iter_set_var*\n operations.\n\n A constrained variable is guaranteed not to change values while results are\n being iterated.\n\n @param it The iterator.\n @param var_id The variable index.\n @return Whether the variable is constrained to a specified value."]
    pub fn ecs_iter_var_is_constrained(it: *mut ecs_iter_t, var_id: i32) -> bool;
}
extern "C" {
    #[doc = " Returns whether current iterator result has changed.\n This operation must be used in combination with a query that supports change\n detection (e.g. is cached). The operation returns whether the currently\n iterated result has changed since the last time it was iterated by the query.\n\n Change detection works on a per-table basis. Changes to individual entities\n cannot be detected this way.\n\n @param it The iterator.\n @return True if the result changed, false if it didn't."]
    pub fn ecs_iter_changed(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Convert iterator to string.\n Prints the contents of an iterator to a string. Useful for debugging and/or\n testing the output of an iterator.\n\n The function only converts the currently iterated data to a string. To\n convert all data, the application has to manually call the next function and\n call ecs_iter_str() on each result.\n\n @param it The iterator.\n @return A string representing the contents of the iterator."]
    pub fn ecs_iter_str(it: *const ecs_iter_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Create a paged iterator.\n Paged iterators limit the results to those starting from 'offset', and will\n return at most 'limit' results.\n\n The iterator must be iterated with ecs_page_next().\n\n A paged iterator acts as a passthrough for data exposed by the parent\n iterator, so that any data provided by the parent will also be provided by\n the paged iterator.\n\n @param it The source iterator.\n @param offset The number of entities to skip.\n @param limit The maximum number of entities to iterate.\n @return A page iterator."]
    pub fn ecs_page_iter(it: *const ecs_iter_t, offset: i32, limit: i32) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress a paged iterator.\n Progresses an iterator created by ecs_page_iter().\n\n @param it The iterator.\n @return true if iterator has more results, false if not."]
    pub fn ecs_page_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Create a worker iterator.\n Worker iterators can be used to equally divide the number of matched entities\n across N resources (usually threads). Each resource will process the total\n number of matched entities divided by 'count'.\n\n Entities are distributed across resources such that the distribution is\n stable between queries. Two queries that match the same table are guaranteed\n to match the same entities in that table.\n\n The iterator must be iterated with ecs_worker_next().\n\n A worker iterator acts as a passthrough for data exposed by the parent\n iterator, so that any data provided by the parent will also be provided by\n the worker iterator.\n\n @param it The source iterator.\n @param index The index of the current resource.\n @param count The total number of resources to divide entities between.\n @return A worker iterator."]
    pub fn ecs_worker_iter(it: *const ecs_iter_t, index: i32, count: i32) -> ecs_iter_t;
}
extern "C" {
    #[doc = " Progress a worker iterator.\n Progresses an iterator created by ecs_worker_iter().\n\n @param it The iterator.\n @return true if iterator has more results, false if not."]
    pub fn ecs_worker_next(it: *mut ecs_iter_t) -> bool;
}
extern "C" {
    #[doc = " Get data for field.\n This operation retrieves a pointer to an array of data that belongs to the\n term in the query. The index refers to the location of the term in the query,\n and starts counting from zero.\n\n For example, the query `\"Position, Velocity\"` will return the `Position` array\n for index 0, and the `Velocity` array for index 1.\n\n When the specified field is not owned by the entity this function returns a\n pointer instead of an array. This happens when the source of a field is not\n the entity being iterated, such as a shared component (from a prefab), a\n component from a parent, or another entity. The ecs_field_is_self() operation\n can be used to test dynamically if a field is owned.\n\n When a field contains a sparse component, use the ecs_field_at function. When\n a field is guaranteed to be set and owned, the ecs_field_self() function can be\n used. ecs_field_self() has slightly better performance, and provides stricter\n validity checking.\n\n The provided size must be either 0 or must match the size of the type\n of the returned array. If the size does not match, the operation may assert.\n The size can be dynamically obtained with ecs_field_size().\n\n An example:\n\n @code\n while (ecs_query_next(&it)) {\n   Position *p = ecs_field(&it, Position, 0);\n   Velocity *v = ecs_field(&it, Velocity, 1);\n   for (int32_t i = 0; i < it->count; i ++) {\n     p[i].x += v[i].x;\n     p[i].y += v[i].y;\n   }\n }\n @endcode\n\n @param it The iterator.\n @param size The size of the field type.\n @param index The index of the field.\n @return A pointer to the data of the field."]
    pub fn ecs_field_w_size(
        it: *const ecs_iter_t,
        size: usize,
        index: i8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get data for field at specified row.\n This operation should be used instead of ecs_field_w_size for sparse\n component fields. This operation should be called for each returned row in a\n result. In the following example the Velocity component is sparse:\n\n @code\n while (ecs_query_next(&it)) {\n   Position *p = ecs_field(&it, Position, 0);\n   for (int32_t i = 0; i < it->count; i ++) {\n     Velocity *v = ecs_field_at(&it, Velocity, 1);\n     p[i].x += v->x;\n     p[i].y += v->y;\n   }\n }\n @endcode\n\n @param it the iterator.\n @param size The size of the field type.\n @param index The index of the field.\n @return A pointer to the data of the field."]
    pub fn ecs_field_at_w_size(
        it: *const ecs_iter_t,
        size: usize,
        index: i8,
        row: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Test whether the field is readonly.\n This operation returns whether the field is readonly. Readonly fields are\n annotated with [in], or are added as a const type in the C++ API.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is readonly."]
    pub fn ecs_field_is_readonly(it: *const ecs_iter_t, index: i8) -> bool;
}
extern "C" {
    #[doc = " Test whether the field is writeonly.\n This operation returns whether this is a writeonly field. Writeonly terms are\n annotated with [out].\n\n Serializers are not required to serialize the values of a writeonly field.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is writeonly."]
    pub fn ecs_field_is_writeonly(it: *const ecs_iter_t, index: i8) -> bool;
}
extern "C" {
    #[doc = " Test whether field is set.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is set."]
    pub fn ecs_field_is_set(it: *const ecs_iter_t, index: i8) -> bool;
}
extern "C" {
    #[doc = " Return id matched for field.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The id matched for the field."]
    pub fn ecs_field_id(it: *const ecs_iter_t, index: i8) -> ecs_id_t;
}
extern "C" {
    #[doc = " Return index of matched table column.\n This function only returns column indices for fields that have been matched\n on the $this variable. Fields matched on other tables will return -1.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The index of the matched column, -1 if not matched."]
    pub fn ecs_field_column(it: *const ecs_iter_t, index: i8) -> i32;
}
extern "C" {
    #[doc = " Return field source.\n The field source is the entity on which the field was matched.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The source for the field."]
    pub fn ecs_field_src(it: *const ecs_iter_t, index: i8) -> ecs_entity_t;
}
extern "C" {
    #[doc = " Return field type size.\n Return type size of the field. Returns 0 if the field has no data.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return The type size for the field."]
    pub fn ecs_field_size(it: *const ecs_iter_t, index: i8) -> usize;
}
extern "C" {
    #[doc = " Test whether the field is matched on self.\n This operation returns whether the field is matched on the currently iterated\n entity. This function will return false when the field is owned by another\n entity, such as a parent or a prefab.\n\n When this operation returns false, the field must be accessed as a single\n value instead of an array. Fields for which this operation returns true\n return arrays with it->count values.\n\n @param it The iterator.\n @param index The index of the field in the iterator.\n @return Whether the field is matched on self."]
    pub fn ecs_field_is_self(it: *const ecs_iter_t, index: i8) -> bool;
}
extern "C" {
    #[doc = " Get type for table.\n The table type is a vector that contains all component, tag and pair ids.\n\n @param table The table.\n @return The type of the table."]
    pub fn ecs_table_get_type(table: *const ecs_table_t) -> *const ecs_type_t;
}
extern "C" {
    #[doc = " Get type index for id.\n This operation returns the index for an id in the table's type.\n\n @param world The world.\n @param table The table.\n @param id The id.\n @return The index of the id in the table type, or -1 if not found.\n\n @see ecs_table_has_id()"]
    pub fn ecs_table_get_type_index(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Get column index for id.\n This operation returns the column index for an id in the table's type. If the\n id is not a component, the function will return -1.\n\n @param world The world.\n @param table The table.\n @param id The component id.\n @return The column index of the id, or -1 if not found/not a component."]
    pub fn ecs_table_get_column_index(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Return number of columns in table.\n Similar to `ecs_table_get_type(table)->count`, except that the column count\n only counts the number of components in a table.\n\n @param table The table.\n @return The number of columns in the table."]
    pub fn ecs_table_column_count(table: *const ecs_table_t) -> i32;
}
extern "C" {
    #[doc = " Convert type index to column index.\n Tables have an array of columns for each component in the table. This array\n does not include elements for tags, which means that the index for a\n component in the table type is not necessarily the same as the index in the\n column array. This operation converts from an index in the table type to an\n index in the column array.\n\n @param table The table.\n @param index The index in the table type.\n @return The index in the table column array.\n\n @see ecs_table_column_to_type_index()"]
    pub fn ecs_table_type_to_column_index(table: *const ecs_table_t, index: i32) -> i32;
}
extern "C" {
    #[doc = " Convert column index to type index.\n Same as ecs_table_type_to_column_index(), but converts from an index in the\n column array to an index in the table type.\n\n @param table The table.\n @param index The column index.\n @return The index in the table type."]
    pub fn ecs_table_column_to_type_index(table: *const ecs_table_t, index: i32) -> i32;
}
extern "C" {
    #[doc = " Get column from table by column index.\n This operation returns the component array for the provided index.\n\n @param table The table.\n @param index The column index.\n @param offset The index of the first row to return (0 for entire column).\n @return The component array, or NULL if the index is not a component."]
    pub fn ecs_table_get_column(
        table: *const ecs_table_t,
        index: i32,
        offset: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get column from table by component id.\n This operation returns the component array for the provided component  id.\n\n @param world The world.\n @param table The table.\n @param id The component id for the column.\n @param offset The index of the first row to return (0 for entire column).\n @return The component array, or NULL if the index is not a component."]
    pub fn ecs_table_get_id(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
        offset: i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get column size from table.\n This operation returns the component size for the provided index.\n\n @param table The table.\n @param index The column index.\n @return The component size, or 0 if the index is not a component."]
    pub fn ecs_table_get_column_size(table: *const ecs_table_t, index: i32) -> usize;
}
extern "C" {
    #[doc = " Returns the number of entities in the table.\n This operation returns the number of entities in the table.\n\n @param table The table.\n @return The number of entities in the table."]
    pub fn ecs_table_count(table: *const ecs_table_t) -> i32;
}
extern "C" {
    #[doc = " Returns allocated size of table.\n This operation returns the number of elements allocated in the table\n per column.\n\n @param table The table.\n @return The number of allocated elements in the table."]
    pub fn ecs_table_size(table: *const ecs_table_t) -> i32;
}
extern "C" {
    #[doc = " Returns array with entity ids for table.\n The size of the returned array is the result of ecs_table_count().\n\n @param table The table.\n @return Array with entity ids for table."]
    pub fn ecs_table_entities(table: *const ecs_table_t) -> *const ecs_entity_t;
}
extern "C" {
    #[doc = " Test if table has id.\n Same as `ecs_table_get_type_index(world, table, id) != -1`.\n\n @param world The world.\n @param table The table.\n @param id The id.\n @return True if the table has the id, false if the table doesn't.\n\n @see ecs_table_get_type_index()"]
    pub fn ecs_table_has_id(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Return depth for table in tree for relationship rel.\n Depth is determined by counting the number of targets encountered while\n traversing up the relationship tree for rel. Only acyclic relationships are\n supported.\n\n @param world The world.\n @param table The table.\n @param rel The relationship.\n @return The depth of the table in the tree."]
    pub fn ecs_table_get_depth(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        rel: ecs_entity_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Get table that has all components of current table plus the specified id.\n If the provided table already has the provided id, the operation will return\n the provided table.\n\n @param world The world.\n @param table The table.\n @param id The id to add.\n @result The resulting table."]
    pub fn ecs_table_add_id(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        id: ecs_id_t,
    ) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Find table from id array.\n This operation finds or creates a table with the specified array of\n (component) ids. The ids in the array must be sorted, and it may not contain\n duplicate elements.\n\n @param world The world.\n @param ids The id array.\n @param id_count The number of elements in the id array.\n @return The table with the specified (component) ids."]
    pub fn ecs_table_find(
        world: *mut ecs_world_t,
        ids: *const ecs_id_t,
        id_count: i32,
    ) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Get table that has all components of current table minus the specified id.\n If the provided table doesn't have the provided id, the operation will return\n the provided table.\n\n @param world The world.\n @param table The table.\n @param id The id to remove.\n @result The resulting table."]
    pub fn ecs_table_remove_id(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        id: ecs_id_t,
    ) -> *mut ecs_table_t;
}
extern "C" {
    #[doc = " Lock a table.\n When a table is locked, modifications to it will throw an assert. When the\n table is locked recursively, it will take an equal amount of unlock\n operations to actually unlock the table.\n\n Table locks can be used to build safe iterators where it is guaranteed that\n the contents of a table are not modified while it is being iterated.\n\n The operation only works when called on the world, and has no side effects\n when called on a stage. The assumption is that when called on a stage,\n operations are deferred already.\n\n @param world The world.\n @param table The table to lock."]
    pub fn ecs_table_lock(world: *mut ecs_world_t, table: *mut ecs_table_t);
}
extern "C" {
    #[doc = " Unlock a table.\n Must be called after calling ecs_table_lock().\n\n @param world The world.\n @param table The table to unlock."]
    pub fn ecs_table_unlock(world: *mut ecs_world_t, table: *mut ecs_table_t);
}
extern "C" {
    #[doc = " Test table for flags.\n Test if table has all of the provided flags. See\n include/flecs/private/api_flags.h for a list of table flags that can be used\n with this function.\n\n @param table The table.\n @param flags The flags to test for.\n @return Whether the specified flags are set for the table."]
    pub fn ecs_table_has_flags(table: *mut ecs_table_t, flags: ecs_flags32_t) -> bool;
}
extern "C" {
    #[doc = " Swaps two elements inside the table. This is useful for implementing custom\n table sorting algorithms.\n @param world The world\n @param table The table to swap elements in\n @param row_1 Table element to swap with row_2\n @param row_2 Table element to swap with row_1"]
    pub fn ecs_table_swap_rows(
        world: *mut ecs_world_t,
        table: *mut ecs_table_t,
        row_1: i32,
        row_2: i32,
    );
}
extern "C" {
    #[doc = " Commit (move) entity to a table.\n This operation moves an entity from its current table to the specified\n table. This may cause the following actions:\n - Ctor for each component in the target table\n - Move for each overlapping component\n - Dtor for each component in the source table.\n - `OnAdd` triggers for non-overlapping components in the target table\n - `OnRemove` triggers for non-overlapping components in the source table.\n\n This operation is a faster than adding/removing components individually.\n\n The application must explicitly provide the difference in components between\n tables as the added/removed parameters. This can usually be derived directly\n from the result of ecs_table_add_id() and ecs_table_remove_id(). These arrays are\n required to properly execute `OnAdd`/`OnRemove` triggers.\n\n @param world The world.\n @param entity The entity to commit.\n @param record The entity's record (optional, providing it saves a lookup).\n @param table The table to commit the entity to.\n @return True if the entity got moved, false otherwise."]
    pub fn ecs_commit(
        world: *mut ecs_world_t,
        entity: ecs_entity_t,
        record: *mut ecs_record_t,
        table: *mut ecs_table_t,
        added: *const ecs_type_t,
        removed: *const ecs_type_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Search for component id in table type.\n This operation returns the index of first occurrence of the id in the table\n type. The id may be a wildcard.\n\n When id_out is provided, the function will assign it with the found id. The\n found id may be different from the provided id if it is a wildcard.\n\n This is a constant time operation.\n\n @param world The world.\n @param table The table.\n @param id The id to search for.\n @param id_out If provided, it will be set to the found id (optional).\n @return The index of the id in the table type.\n\n @see ecs_search_offset()\n @see ecs_search_relation()"]
    pub fn ecs_search(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        id: ecs_id_t,
        id_out: *mut ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Search for component id in table type starting from an offset.\n This operation is the same as ecs_search(), but starts searching from an offset\n in the table type.\n\n This operation is typically called in a loop where the resulting index is\n used in the next iteration as offset:\n\n @code\n int32_t index = -1;\n while ((index = ecs_search_offset(world, table, offset, id, NULL))) {\n   // do stuff\n }\n @endcode\n\n Depending on how the operation is used it is either linear or constant time.\n When the id has the form `(id)` or `(rel, *)` and the operation is invoked as\n in the above example, it is guaranteed to be constant time.\n\n If the provided id has the form `(*, tgt)` the operation takes linear time. The\n reason for this is that ids for an target are not packed together, as they\n are sorted relationship first.\n\n If the id at the offset does not match the provided id, the operation will do\n a linear search to find a matching id.\n\n @param world The world.\n @param table The table.\n @param offset Offset from where to start searching.\n @param id The id to search for.\n @param id_out If provided, it will be set to the found id (optional).\n @return The index of the id in the table type.\n\n @see ecs_search()\n @see ecs_search_relation()"]
    pub fn ecs_search_offset(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        offset: i32,
        id: ecs_id_t,
        id_out: *mut ecs_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Search for component/relationship id in table type starting from an offset.\n This operation is the same as ecs_search_offset(), but has the additional\n capability of traversing relationships to find a component. For example, if\n an application wants to find a component for either the provided table or a\n prefab (using the `IsA` relationship) of that table, it could use the operation\n like this:\n\n @code\n int32_t index = ecs_search_relation(\n   world,            // the world\n   table,            // the table\n   0,                // offset 0\n   ecs_id(Position), // the component id\n   EcsIsA,           // the relationship to traverse\n   0,                // start at depth 0 (the table itself)\n   0,                // no depth limit\n   NULL,             // (optional) entity on which component was found\n   NULL,             // see above\n   NULL);            // internal type with information about matched id\n @endcode\n\n The operation searches depth first. If a table type has 2 `IsA` relationships, the\n operation will first search the `IsA` tree of the first relationship.\n\n When choosing between ecs_search(), ecs_search_offset() and ecs_search_relation(),\n the simpler the function the better its performance.\n\n @param world The world.\n @param table The table.\n @param offset Offset from where to start searching.\n @param id The id to search for.\n @param rel The relationship to traverse (optional).\n @param flags Whether to search EcsSelf and/or EcsUp.\n @param subject_out If provided, it will be set to the matched entity.\n @param id_out If provided, it will be set to the found id (optional).\n @param tr_out Internal datatype.\n @return The index of the id in the table type.\n\n @see ecs_search()\n @see ecs_search_offset()"]
    pub fn ecs_search_relation(
        world: *const ecs_world_t,
        table: *const ecs_table_t,
        offset: i32,
        id: ecs_id_t,
        rel: ecs_entity_t,
        flags: ecs_flags64_t,
        subject_out: *mut ecs_entity_t,
        id_out: *mut ecs_id_t,
        tr_out: *mut *mut ecs_table_record_t,
    ) -> i32;
}
extern "C" {
    #[doc = " Construct a value in existing storage\n\n @param world The world.\n @param type The type of the value to create.\n @param ptr Pointer to a value of type 'type'\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_init(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a value in existing storage\n\n @param world The world.\n @param ti The type info of the type to create.\n @param ptr Pointer to a value of type 'type'\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_init_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a value in new storage\n\n @param world The world.\n @param type The type of the value to create.\n @return Pointer to type if success, NULL if failed."]
    pub fn ecs_value_new(
        world: *mut ecs_world_t,
        type_: ecs_entity_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Construct a value in new storage\n\n @param world The world.\n @param ti The type info of the type to create.\n @return Pointer to type if success, NULL if failed."]
    pub fn ecs_value_new_w_type_info(
        world: *mut ecs_world_t,
        ti: *const ecs_type_info_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Destruct a value\n\n @param world The world.\n @param ti Type info of the value to destruct.\n @param ptr Pointer to constructed value of type 'type'.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_fini_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destruct a value\n\n @param world The world.\n @param type The type of the value to destruct.\n @param ptr Pointer to constructed value of type 'type'.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_fini(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Destruct a value, free storage\n\n @param world The world.\n @param type The type of the value to destruct.\n @param ptr A pointer to the value.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_free(
        world: *mut ecs_world_t,
        type_: ecs_entity_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy value.\n\n @param world The world.\n @param ti Type info of the value to copy.\n @param dst Pointer to the storage to copy to.\n @param src Pointer to the value to copy.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_copy_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy value.\n\n @param world The world.\n @param type The type of the value to copy.\n @param dst Pointer to the storage to copy to.\n @param src Pointer to the value to copy.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_copy(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        dst: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move value.\n\n @param world The world.\n @param ti Type info of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move value.\n\n @param world The world.\n @param type The type of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move construct value.\n\n @param world The world.\n @param ti Type info of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move_ctor_w_type_info(
        world: *const ecs_world_t,
        ti: *const ecs_type_info_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move construct value.\n\n @param world The world.\n @param type The type of the value to move.\n @param dst Pointer to the storage to move to.\n @param src Pointer to the value to move.\n @return Zero if success, nonzero if failed."]
    pub fn ecs_value_move_ctor(
        world: *const ecs_world_t,
        type_: ecs_entity_t,
        dst: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\n Logging functions (do nothing when logging is enabled)\n"]
    pub fn ecs_print_(
        level: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_printv_(
        level: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn ecs_log_(
        level: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_logv_(
        level: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    pub fn ecs_abort_(
        error_code: i32,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_assert_log_(
        error_code: i32,
        condition_str: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: i32,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_parser_error_(
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        column: i64,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn ecs_parser_errorv_(
        name: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        column: i64,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    );
}
extern "C" {
    #[doc = " Enable or disable log.\n This will enable builtin log. For log to work, it will have to be\n compiled in which requires defining one of the following macros:\n\n FLECS_LOG_0 - All log is disabled\n FLECS_LOG_1 - Enable log level 1\n FLECS_LOG_2 - Enable log level 2 and below\n FLECS_LOG_3 - Enable log level 3 and below\n\n If no log level is defined and this is a debug build, FLECS_LOG_3 will\n have been automatically defined.\n\n The provided level corresponds with the log level. If -1 is provided as\n value, warnings are disabled. If -2 is provided, errors are disabled as well.\n\n @param level Desired tracing level.\n @return Previous log level."]
    pub fn ecs_log_set_level(level: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get current log level.\n\n @return Previous log level."]
    pub fn ecs_log_get_level() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Enable/disable tracing with colors.\n By default colors are enabled.\n\n @param enabled Whether to enable tracing with colors.\n @return Previous color setting."]
    pub fn ecs_log_enable_colors(enabled: bool) -> bool;
}
extern "C" {
    #[doc = " Enable/disable logging timestamp.\n By default timestamps are disabled. Note that enabling timestamps introduces\n overhead as the logging code will need to obtain the current time.\n\n @param enabled Whether to enable tracing with timestamps.\n @return Previous timestamp setting."]
    pub fn ecs_log_enable_timestamp(enabled: bool) -> bool;
}
extern "C" {
    #[doc = " Enable/disable logging time since last log.\n By default deltatime is disabled. Note that enabling timestamps introduces\n overhead as the logging code will need to obtain the current time.\n\n When enabled, this logs the amount of time in seconds passed since the last\n log, when this amount is non-zero. The format is a '+' character followed by\n the number of seconds:\n\n     +1 trace: log message\n\n @param enabled Whether to enable tracing with timestamps.\n @return Previous timestamp setting."]
    pub fn ecs_log_enable_timedelta(enabled: bool) -> bool;
}
extern "C" {
    #[doc = " Get last logged error code.\n Calling this operation resets the error code.\n\n @return Last error, 0 if none was logged since last call to last_error."]
    pub fn ecs_log_last_error() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[doc = "< Table cache of element. Of type ecs_id_record_t* for component index elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_table_cache_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_event_id_record_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_var_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_op_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ecs_query_op_ctx_t {
    pub _address: u8,
}
